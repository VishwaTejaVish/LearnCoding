[
    {
        "id": 1,
        "title": "What is React",
        "description": "React.js (often referred to simply as React) is an open-source JavaScript library developed by Facebook, primarily used for building user interfaces (UIs), especially for single-page applications (SPAs). \n\nIt enables developers to create large web applications that can update and render efficiently in response to data changes without reloading the entire page. \n\nKey Features of React: \n\nComponent-Based Architecture: \nReact applications are built using components. Each component represents a part of the user interface and can be reused across different parts of the app, making development more modular and maintainable. \n\nVirtual DOM: \nReact uses a virtual DOM (a lightweight copy of the real DOM) to optimize rendering. When the state of an object changes, React updates the virtual DOM first, and then compares it with the actual DOM. Only the differences are updated in the real DOM, which improves performance. \n\nJSX (JavaScript XML): \nReact introduces JSX, a syntax that looks like HTML but is written within JavaScript. JSX makes it easier to write and visualize the structure of the UI by combining JavaScript logic and HTML-like markup. \n\nOne-Way Data Binding: \nReact follows a one-way data flow, meaning that data flows from parent components to child components. This makes it easier to debug and manage large applications by keeping track of data changes. \n\nDeclarative UI: React allows developers to describe how the UI should look based on the current state of the application. React automatically updates and re-renders the components when the state changes, abstracting away the DOM manipulation. \n\nReact Hooks: \nIntroduced in React 16.8, hooks allow developers to use state and other React features in functional components, making code simpler and more readable.\n\nEcosystem: \nReact has a vast ecosystem with libraries for state management (e.g., Redux, Context API), routing (e.g., React Router), and more. It also supports server-side rendering (SSR) through frameworks like Next.js."
    },
    {
        "id": 2,
        "title": "Life Cycle Methods",
        "description": "React components go through a series of phases, collectively referred to as the React component lifecycle. These phases represent how a component is created, updated, and eventually removed from the DOM. In React, these lifecycle methods are particularly useful when building dynamic applications as they give developers hooks to execute specific code at each phase. \n\nReact components lifecycle can be broken down into three main stages: \nMounting (when the component is created and inserted into the DOM) \nUpdating (when the component is re-rendered as a result of state or prop changes) \nUnmounting (when the component is removed from the DOM) \n\n1. Mounting Mounting refers to the process of inserting a component into the DOM for the first time. The lifecycle methods related to mounting are: \nconstructor(props): \nThis is the first method called when a component is initiated. It is used to set the initial state and bind methods. \nstatic getDerivedStateFromProps(props, state): \nRarely used, this method allows a component to update its state in response to prop changes before the initial render. It returns an object to update the state, or null if no update is necessary. \nrender(): The only required method in a class component, render() returns the JSX that represents the component’s UI. \ncomponentDidMount(): \nThis method is called immediately after the component is mounted (inserted into the DOM). It’s commonly used for making API calls, setting up subscriptions, or initializing DOM nodes. \n\n2. Updating \nA component can update due to changes in its props or state. React provides the following lifecycle methods for the update phase: \nstatic getDerivedStateFromProps(props, state): \nAs in the mounting phase, this method can be used to update state based on changing props. It’s called both during mounting and updating. \nshouldComponentUpdate(nextProps, nextState): This method allows you to prevent unnecessary re-rendering by returning false if the update is not needed. This is useful for performance optimization. \nrender(): As in the mounting phase, render() is called during updates to return the JSX for the component. \ngetSnapshotBeforeUpdate(prevProps, prevState): Called right before the DOM is updated. It gives access to the DOM before the changes are applied and can be used to capture the current scroll position or dimensions. \ncomponentDidUpdate(prevProps, prevState, snapshot): Called immediately after the component is updated. This is a good place to interact with the updated DOM, perform additional data fetching, or trigger animations based on changes. \n\n3. Unmounting The final stage in the lifecycle is unmounting, which happens when a component is removed from the DOM. There is one lifecycle method associated with this phase: \ncomponentWillUnmount(): \nThis method is called right before a component is removed from the DOM. It is commonly used to clean up resources such as event listeners, timers, or network requests."
    },
    {
        "id": 3,
        "title": "JSX",
        "description": "JSX (JavaScript XML) is a syntax extension for JavaScript that is used in React to describe what the UI should look like. It allows you to write HTML-like code inside your JavaScript, which React then transforms into React elements. \n\nJSX is a key feature of React because it allows developers to combine JavaScript logic and HTML-like markup in a more readable and expressive way. \n\nKey Features of JSX: \nLooks Like HTML but It's Not: \nJSX looks similar to HTML or XML, but it’s not the same. Each JSX element is converted to JavaScript, allowing developers to integrate React components easily within their UI. \nEmbedding JavaScript Expressions: \nYou can embed JavaScript expressions inside JSX by wrapping them in curly braces {}. This allows you to dynamically render values. \nJSX Attributes: \nJust like HTML attributes, JSX allows you to add attributes to elements. However, since JSX is essentially JavaScript, some attributes like class are written as className (to avoid conflicts with JavaScript keywords). \nJSX Must Return a Single Parent Element: \nJSX expressions must return a single parent element. If you need to return multiple elements, you must wrap them in a container element (like a <div>) or use React fragments (<>...</>). \nSelf-Closing Tags: \nJust like in HTML, some tags can be self-closing. In JSX, this is required for elements that don’t have children (e.g., <img />, <input />). \nConditional Rendering: \nYou can conditionally render elements using JavaScript logic within JSX. \n\nWhy JSX is Useful in React: \nSimplicity: \nJSX makes it easier to visualize the structure of the UI since the markup is embedded within the JavaScript code. \nIntegration with JavaScript: \nJSX allows seamless integration with JavaScript, enabling you to write logic and UI in the same place. This makes it easier to work with dynamic data and handle events. \nDeveloper Experience: \nJSX offers better error messages, auto-completion in IDEs, and easier debugging, which improves the overall developer experience. \nJSX Compilation: Since browsers do not understand JSX, a transpiler like Babel is used to transform JSX into regular JavaScript code."
    },
    {
        "id": 4,
        "title": "Components"
    },
    {
        "id": 5,
        "title": "Props"
    },
    {
        "id": 6,
        "title": "Events"
    }
]
