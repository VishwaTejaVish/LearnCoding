[
  {
    "id": 1,
    "title": "What is React",
    "description": "React.js (often referred to simply as React) is an open-source JavaScript library developed by Facebook, primarily used for building user interfaces (UIs), especially for single-page applications (SPAs). \n\nIt enables developers to create large web applications that can update and render efficiently in response to data changes without reloading the entire page. \n\nKey Features of React: \n\nComponent-Based Architecture: \nReact applications are built using components. Each component represents a part of the user interface and can be reused across different parts of the app, making development more modular and maintainable. \n\nVirtual DOM: \nReact uses a virtual DOM (a lightweight copy of the real DOM) to optimize rendering. When the state of an object changes, React updates the virtual DOM first, and then compares it with the actual DOM. Only the differences are updated in the real DOM, which improves performance. \n\nJSX (JavaScript XML): \nReact introduces JSX, a syntax that looks like HTML but is written within JavaScript. JSX makes it easier to write and visualize the structure of the UI by combining JavaScript logic and HTML-like markup. \n\nOne-Way Data Binding: \nReact follows a one-way data flow, meaning that data flows from parent components to child components. This makes it easier to debug and manage large applications by keeping track of data changes. \n\nDeclarative UI: React allows developers to describe how the UI should look based on the current state of the application. React automatically updates and re-renders the components when the state changes, abstracting away the DOM manipulation. \n\nReact Hooks: \nIntroduced in React 16.8, hooks allow developers to use state and other React features in functional components, making code simpler and more readable.\n\nEcosystem: \nReact has a vast ecosystem with libraries for state management (e.g., Redux, Context API), routing (e.g., React Router), and more. It also supports server-side rendering (SSR) through frameworks like Next.js.",
    "highlightWords": [
      "key features of react:",
      "component-based architecture:",
      "virtual dom:",
      "jsx (javascript xml):",
      "one-way data binding:",
      "declarative ui:",
      "react hooks:",
      "ecosystem:"
    ]
  },
  {
    "id": 2,
    "title": "Life Cycle Methods",
    "description": "React components go through a series of phases, collectively referred to as the React component lifecycle. These phases represent how a component is created, updated, and eventually removed from the DOM. \nIn React, these lifecycle methods are particularly useful when building dynamic applications as they give developers hooks to execute specific code at each phase. \n\nReact components lifecycle can be broken down into three main stages: \n\n1. Mounting Mounting refers to the process of inserting a component into the DOM for the first time. The lifecycle methods related to mounting are: \n\nconstructor(props): \nThis is the first method called when a component is initiated. It is used to set the initial state and bind methods. \n\nstatic getDerivedStateFromProps(props, state): \nRarely used, this method allows a component to update its state in response to prop changes before the initial render. It returns an object to update the state, or null if no update is necessary. \n\nrender(): The only required method in a class component, render() returns the JSX that represents the component’s UI. \n\ncomponentDidMount(): \nThis method is called immediately after the component is mounted (inserted into the DOM). It’s commonly used for making API calls, setting up subscriptions, or initializing DOM nodes. \n\n2. Updating \nA component can update due to changes in its props or state. React provides the following lifecycle methods for the update phase: \n\nstatic getDerivedStateFromProps(props, state): \nAs in the mounting phase, this method can be used to update state based on changing props. It’s called both during mounting and updating. \n\nshouldComponentUpdate(nextProps, nextState): This method allows you to prevent unnecessary re-rendering by returning false if the update is not needed. This is useful for performance optimization. \n\nrender(): As in the mounting phase, render() is called during updates to return the JSX for the component. \n\ngetSnapshotBeforeUpdate(prevProps, prevState): Called right before the DOM is updated. It gives access to the DOM before the changes are applied and can be used to capture the current scroll position or dimensions. \n\ncomponentDidUpdate(prevProps, prevState, snapshot): Called immediately after the component is updated. This is a good place to interact with the updated DOM, perform additional data fetching, or trigger animations based on changes. \n\n3. Unmounting The final stage in the lifecycle is unmounting, which happens when a component is removed from the DOM. There is one lifecycle method associated with this phase: \n\ncomponentWillUnmount(): \nThis method is called right before a component is removed from the DOM. It is commonly used to clean up resources such as event listeners, timers, or network requests.",
    "highlightWords": [
      "react components lifecycle can be broken down into three main stages:",
      "1. mounting",
      "constructor(props):",
      "static getderivedstatefromprops(props, state):",
      "render():",
      "componentdidmount():",
      "2. updating",
      "shouldcomponentupdate(nextprops, nextstate):",
      "getsnapshotbeforeupdate(prevprops, prevstate):",
      "componentdidupdate(prevprops, prevstate, snapshot):",
      "3. unmounting",
      "componentwillunmount():"
    ]
  },
  {
    "id": 3,
    "title": "JSX",
    "description": "JSX (JavaScript XML) is a syntax extension for JavaScript that is used in React to describe what the UI should look like. It allows you to write HTML-like code inside your JavaScript, which React then transforms into React elements. \n\nJSX is a key feature of React because it allows developers to combine JavaScript logic and HTML-like markup in a more readable and expressive way. \n\nKey Features of JSX: \n\nLooks Like HTML but It's Not: \nJSX looks similar to HTML or XML, but it’s not the same. Each JSX element is converted to JavaScript, allowing developers to integrate React components easily within their UI. \n\nEmbedding JavaScript Expressions: \nYou can embed JavaScript expressions inside JSX by wrapping them in curly braces {}. This allows you to dynamically render values. \n\nJSX Attributes: \nJust like HTML attributes, JSX allows you to add attributes to elements. However, since JSX is essentially JavaScript, some attributes like class are written as className (to avoid conflicts with JavaScript keywords). \n\nJSX Must Return a Single Parent Element: \nJSX expressions must return a single parent element. If you need to return multiple elements, you must wrap them in a container element (like a <div>) or use React fragments (<>...</>). \n\nSelf-Closing Tags: \nJust like in HTML, some tags can be self-closing. In JSX, this is required for elements that don’t have children (e.g., <img />, <input />). \n\nConditional Rendering: \nYou can conditionally render elements using JavaScript logic within JSX. \n\nWhy JSX is Useful in React: \n\nSimplicity: \nJSX makes it easier to visualize the structure of the UI since the markup is embedded within the JavaScript code. \n\nIntegration with JavaScript: \nJSX allows seamless integration with JavaScript, enabling you to write logic and UI in the same place. This makes it easier to work with dynamic data and handle events. \n\nDeveloper Experience: \nJSX offers better error messages, auto-completion in IDEs, and easier debugging, which improves the overall developer experience. \n\nJSX Compilation: Since browsers do not understand JSX, a transpiler like Babel is used to transform JSX into regular JavaScript code.",
    "highlightWords": [
      "key features of jsx:",
      "looks like html but it's not:",
      "embedding javascript expressions:",
      "jsx attributes:",
      "jsx must return a single parent element:",
      "self-closing tags:",
      "conditional rendering:",
      "jsx compilation:",
      "developer experience:",
      "integration with javascript:",
      "simplicity:",
      "why jsx is useful in react:"
    ]
  },
  {
    "id": 4,
    "title": "Virtual Dom",
    "description": "The Virtual DOM in React is one of its core concepts, designed to enhance performance by optimizing how updates are made to the actual browser DOM. \nIt is a lightweight copy of the real DOM, allowing React to minimize direct manipulations of the DOM, which can be slow and inefficient. \n\nWhat is the Virtual DOM? \nThe Virtual DOM is essentially an in-memory representation of the real DOM elements. It is a JavaScript object that mirrors the structure of the actual DOM tree but is much more efficient to work with. \nReact uses the virtual DOM to figure out what changes need to be made to the real DOM, and it does so in a way that minimizes performance costs. \n\nHow Does the Virtual DOM Work? \n\nInitial Render: \nWhen a React component renders for the first time, React creates a virtual DOM representation of the UI. This is just a tree of JavaScript objects that describes what the UI should look like. \n\nState or Props Change: \nWhen the state or props of a component change, React doesn't immediately update the real DOM. Instead, it updates the virtual DOM, creating a new virtual DOM tree based on the new state or props. \n\nDiffing Algorithm: \nReact compares the new virtual DOM tree with the previous version of the virtual DOM. This process is called reconciliation or diffing. React identifies exactly which parts of the UI have changed. \n\nEfficient Updates: \nAfter determining what has changed, React updates only the specific parts of the real DOM that need to be changed. This avoids unnecessary manipulation of the entire DOM, improving performance. \n\nWhy is the Virtual DOM Faster? \nThe real DOM is inherently slow because updating the DOM requires recalculating styles, re-rendering layouts, and causing the browser to repaint the screen. \nBy contrast, the virtual DOM is a lightweight representation, and updates to it are performed quickly in memory. \n\nHere’s why using a virtual DOM speeds things up: \n\nBatching Updates: Instead of updating the real DOM on every small change, React batches updates and applies them all at once. This minimizes costly DOM manipulations. \n\nMinimized Repaints and Reflows: React ensures that only the parts of the real DOM that need to be updated are touched, avoiding unnecessary repaints and reflows in the browser. \n\nEfficient Diffing: React’s diffing algorithm efficiently detects changes between versions of the virtual DOM, ensuring that only the necessary updates are applied to the real DOM. \n\nVirtual DOM Process: \n\nRendering: When a component’s state or props change, React renders the new UI into the virtual DOM. \n\nComparison: React compares the new virtual DOM with the previous virtual DOM (diffing). \n\nMinimal Updates: React identifies what has changed and updates only the parts of the real DOM that have been modified. \n\nReal DOM Update: Finally, React applies the minimal changes to the real DOM. \n\nBenefits of the Virtual DOM: \n\nPerformance: The virtual DOM helps React update only the parts of the UI that actually changed, leading to more efficient updates and better performance compared to directly updating the real DOM. \n\nAbstraction: Developers don’t need to manually manipulate the DOM, as React handles the updates under the hood. \n\nDeclarative UI: The use of the virtual DOM allows React’s declarative style of building UIs. You simply declare what the UI should look like, and React ensures that the DOM reflects that. \n\nVirtual DOM and React Fiber: \nWith the introduction of React Fiber in React 16, the virtual DOM got even better. Fiber allows React to break down updates into smaller chunks and prioritize rendering based on importance, resulting in smoother and more responsive UIs, especially in large applications.",
    "highlightWords": [
      "virtual dom and react fiber:",
      "abstraction",
      "performance:",
      "benefits of the virtual dom:",
      "real dom update:",
      "minimal updates:",
      "comparison:",
      "rendering:",
      "virtual dom process:",
      "efficient diffing:",
      "minimized repaints and reflows:",
      "batching updates:",
      "Here’s why using a virtual DOM speeds things up:",
      "why is the virtual dom faster?",
      "efficient updates:",
      "diffing algorithm:",
      "state or props change:",
      "initial render:",
      "how does the virtual dom work?",
      "what is the virtual dom?",
      "declarative ui:"
    ]
  },
  {
    "id": 5,
    "title": "Props",
    "description": "In React, props (short for 'properties') are used to pass data from one component to another. \nProps allow components to be reusable and dynamic by enabling you to pass values or functions from a parent component to its child components. \n\nKey Concepts of Props in React: \n\nProps are Read-Only: \nProps are immutable, meaning the child component receiving them cannot change the values of props. They are passed down from the parent and should only be used for rendering or computation within the child component. \n\nProps as Function Parameters: \nProps are passed as arguments to components, and they can be accessed inside the component like function parameters. \n\nProps are Passed Down the Component Tree: \nData flows in one direction in React, from parent to child components. The parent component sends data as props to the child component.",
    "highlightWords": [
      "props are passed down the component tree:",
      "props as function parameters:",
      "props are read-only:",
      "key concepts of props in react:"
    ]
  },
  {
    "id": 6,
    "title": "Components",
    "description": [
      "React components are the building blocks of a React application. \nThey allow you to split the UI into independent, reusable pieces and think about each piece in isolation. \nComponents can be either functional or class-based. \n\n1. Functional Components\nFunctional components are simpler and typically used more in modern React development. They are JavaScript functions that accept props as an argument and return React elements (JSX). \n\nExample of a functional component:",
      "import React from 'react'; \nfunction Greeting(props) { \n  return <h1>Hello, {props.name}!</h1>; \n} \nexport default Greeting;",
      "2. Class Components \nClass components were the primary way to create components before React Hooks were introduced. These are ES6 classes that extend from React.Component. They have more features, such as lifecycle methods. \n\nExample of a class component:",
      "import React, { Component } from 'react'; \nclass Greeting extends Component { \n  render() { \n    return <h1>Hello, {this.props.name}!</h1>; \n  } \n} \nexport default Greeting;",
      "Key Concepts in Components:\nProps (Properties): Props are read-only attributes passed from a parent component to a child component. They allow data to flow between components.",
      "<Greeting name='John' />",
      "The name='John' is a prop that gets passed to the Greeting component. \n\nState: State is an object that holds data or variables that may change over time. In class components, state is managed using this.state. In functional components, you can use the useState Hook. \n\nExample of state in a functional component:",
      "import React, { useState } from 'react'; \nfunction Counter() { \n  const [count, setCount] = useState(0); \n  return ( \n    <div> \n     <p>You clicked {count} times</p> \n     <button onClick={() => setCount(count + 1)}> \n      Click me \n     </button> \n    </div> \n ); \n} \nexport default Counter;",
      "Types of Components: \nPresentational Components: Focus on how things look (UI). They receive data via props and render UI accordingly. \nContainer Components: Focus on how things work (logic). They contain state, manage logic, and pass data to child components. \n\nComponent Composition: \nReact encourages you to build components that are small and composable. You can nest components within one another, allowing for modular and maintainable code.",
      "function App() { \n return ( \n  <div> \n   <Greeting name='Alice'/> \n   <Greeting name='Bob'/> \n  </div> \n );\n}",
      "In this example, the App component renders two Greeting components with different props."
    ],
    "indices": [1, 3, 5, 7, 9],
    "highlightWords": [
      "1. Functional Components",
      "2. Class Components",
      "example of a functional component:",
      "example of a class component:",
      "key concepts in components",
      "state:",
      "example of state in a functional component:",
      "types of components:",
      "component composition:"
    ]
  },
  {
    "id": 7,
    "title": "Higher Order Components",
    "description": [
      "In React, a Higher-Order Component (HOC) is a function that takes a component as an argument and returns a new component. HOCs are a pattern used for reusing component logic and are useful when you need to add functionality to existing components without modifying them directly.",
      "\nSyntax and Structure of HOCs \nA higher-order component is just a function that accepts a component and returns a new component:",
      "const withHOC = (WrappedComponent) => {\r\n  return function EnhancedComponent(props) {\r\n    // Additional logic or data to add to the component  \r\n    return <WrappedComponent {...props} />;\r\n  };\r\n};",
      "\nExample of an HOC: Logging Props \nLet’s create an HOC that logs the props of the component it wraps.",
      "import React from 'react';\r\n\r\nfunction withLogging(WrappedComponent) {\r\n  return function EnhancedComponent(props) {\r\n    console.log('Props:', props);\r\n    return <WrappedComponent {...props} />;\r\n  };\r\n}\r\n\r\n// Component to be wrapped\r\nfunction SampleComponent(props) {\r\n  return <div>Hello, {props.name}!</div>;\r\n}\r\n\r\n// Wrapped component with logging functionality\r\nconst SampleWithLogging = withLogging(SampleComponent);\r\n\r\nexport default SampleWithLogging;",
      "\nExplanation: \nwithLogging: The HOC takes a component (WrappedComponent) and returns a new component (EnhancedComponent) that logs the props. \nPassing Props: EnhancedComponent passes down all props to the WrappedComponent using {...props}, maintaining the interface of the original component.",
      "\nCommon Use Cases for HOCs \n1. Code Reuse: Sharing functionality (e.g., authentication checks, data fetching) among multiple components. \n2. Enhancing Components: Adding extra functionality to a component without altering its original structure. \n3. Conditional Rendering: Displaying a component only if certain conditions are met, like authentication or permissions. \n\nExample: Adding Authentication with an HOC \nLet’s create an HOC that only renders a component if the user is authenticated.",
      "import React from 'react';\r\n\r\nfunction withAuth(WrappedComponent) {\r\n  return function AuthComponent(props) {\r\n    const isAuthenticated = // logic to check if the user is authenticated  \r\n\r\n    if (!isAuthenticated) {\r\n      return <div>Please log in to view this content.</div>;\r\n    }\r\n\r\n    return <WrappedComponent {...props} />;\r\n  };\r\n}\r\n\r\n// Usage\r\nfunction Dashboard(props) {\r\n  return <div>Welcome to your dashboard, {props.username}!</div>;\r\n}\r\n\r\nconst ProtectedDashboard = withAuth(Dashboard);\r\n\r\nexport default ProtectedDashboard;",
      "\nExplanation: \nwithAuth: The HOC checks the authentication status. If the user isn’t authenticated, it shows a message; otherwise, it renders the WrappedComponent. \nFlexible Reusability: You could apply withAuth to other components, making it reusable for protecting multiple routes or views.",
      "\nHOC Pitfalls and Best Practices \n1. Static Methods and Context: HOCs can sometimes strip away static methods or context. Libraries like recompose or hoist-non-react-statics help copy non-react static methods to the HOC. \n2. Nested HOCs: Stacking multiple HOCs can make components harder to debug. Wrapping components in too many HOCs can create deeply nested hierarchies and reduce readability. \n3. Render Prop Pattern: For complex scenarios, using the render prop pattern or custom hooks can be preferable to avoid HOC overuse.",
      "\nComparison: HOCs vs. Render Props vs. Hooks \n• HOCs: Great for adding extra behavior and reusing logic across components. However, they can create \"wrapper hell\" with deeply nested components. \n• Render Props: Ideal for sharing logic between components by passing a function as a prop. \n• Hooks: Provide a simpler and more direct way to share logic within functional components without additional nesting, which is why they’re often preferred over HOCs for new code.",
      "\nSummary \n• HOCs are functions that add extra functionality to components, perfect for code reuse and enhancements. \n• Reusable Logic: HOCs help to keep logic DRY by providing reusable patterns for features like authentication, logging, or fetching data. \n• Props Forwarding: They pass props to the wrapped component, keeping the wrapped component’s API consistent. \n\nHigher-order components are a powerful tool in React, providing reusable logic patterns and enhancing components without modifying their original code structure."
    ],
    "indices": [2, 4, 7],
    "highlightWords": [
      "•",
      "Higher-Order Component (HOC)",
      "Syntax and Structure of HOCs",
      "Example of an HOC:",
      "Explanation:",
      "Passing Props:",
      "Common Use Cases for HOCs",
      "1. Code Reuse:",
      "2. Enhancing Components:",
      "3. Conditional Rendering:",
      "Example: Adding Authentication with an HOC",
      "HOC Pitfalls and Best Practices",
      "1. Static Methods and Context:",
      "2. Nested HOCs:",
      "3. Render Prop Pattern:",
      "Summary",
      "withlogging:",
      "withAuth:",
      "HOCs",
      "Reusable Logic:",
      "Props Forwarding:",
      "Comparison: HOCs vs. Render Props vs. Hooks",
      "HOCs:",
      "Render Props:",
      "Hooks:",
      "HOC Pitfalls and Best Practices"
    ]
  },
  {
    "id": 8,
    "title": "useState",
    "description": [
      "useState is a React hook that allows you to add state to functional components. It helps track and update values over time within a component, like user input, counters, toggles, and more. With useState, you can manage local component state in a simple and intuitive way. \n\nBasic Syntax of useState \nTo use useState, import it from React and initialize it within your functional component:",
      "import React, { useState } from 'react';\r\n\r\nfunction ExampleComponent() {\r\n  const [state, setState] = useState(initialValue);\r\n  \r\n  // Usage of state and setState\r\n}",
      "\nParameters: \n1. state: The current state value. This can be any type (string, number, array, object, etc.). \n2. setState: A function to update the state value. When called, React re-renders the component with the new state. \n3. initialValue: The initial value of the state, which can be a constant or a function (for lazy initialization). \n\nExample: Counter with useState \nHere’s an example of a counter that increments each time a button is clicked:",
      "import React, { useState } from 'react';\r\n\r\nfunction Counter() {\r\n  // Declare a state variable called \"count\" and initialize it to 0\r\n  const [count, setCount] = useState(0);\r\n\r\n  // Function to update the count\r\n  const increment = () => {\r\n    setCount(count + 1); // Update state\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>Current Count: {count}</p>\r\n      <button onClick={increment}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Counter;",
      "\nExplanation: \n• const [count, setCount] = useState(0);: Initializes the count state variable with an initial value of 0. setCount is the function that will update count. \n• increment function: This function increments the count by 1 whenever the button is clicked. \n• Re-rendering: When setCount is called, React updates count and re-renders the component with the new value. \n\nExample: Handling Form Input with useState",
      "import React, { useState } from 'react';\r\n\r\nfunction Form() {\r\n  const [name, setName] = useState('');\r\n\r\n  const handleChange = (e) => {\r\n    setName(e.target.value); // Update state with input value\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <input type=\"text\" value={name} onChange={handleChange} placeholder=\"Enter your name\" />  \r\n      <p>Your name is: {name}</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Form;",
      "\nExplanation: \n• setName(e.target.value); updates the name state whenever the input changes. \n• The input element's value is bound to name, so the displayed value updates as the user types. \n\nUpdating Objects and Arrays with useState \nWhen working with objects or arrays, you need to update them immutably to avoid direct modification. \n\nExample: Updating an Object",
      "function UserInfo() {\r\n  const [user, setUser] = useState({ name: 'Alice', age: 25 });\r\n\r\n  const updateAge = () => {\r\n    setUser({ ...user, age: user.age + 1 }); // Spread syntax to copy existing state and modify age   \r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>Name: {user.name}</p>\r\n      <p>Age: {user.age}</p>\r\n      <button onClick={updateAge}>Increase Age</button>  \r\n    </div>\r\n  );\r\n}",
      "Example: Updating an Array",
      "function TodoList() {\r\n  const [todos, setTodos] = useState(['Learn React', 'Build a Project']);  \r\n\r\n  const addTodo = () => {\r\n    setTodos([...todos, 'New Task']); // Spread existing items and add a new one  \r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <ul>\r\n        {todos.map((todo, index) => (\r\n          <li key={index}>{todo}</li>\r\n        ))}\r\n      </ul>\r\n      <button onClick={addTodo}>Add Todo</button>\r\n    </div>\r\n  );\r\n}",
      "\nLazy Initialization of useState \nIf initializing state is computationally expensive, you can pass a function to useState which will run only once (during the initial render).",
      "function ExpensiveComponent() {\r\n  const [value, setValue] = useState(() => {\r\n    console.log('Computing initial state...');\r\n    return computeExpensiveValue();\r\n  });\r\n\r\n  return <p>{value}</p>;\r\n}",
      "\nKey Points: \nState Updates Are Asynchronous: If you need to update based on the previous state, use the callback form: setCount(prevCount => prevCount + 1). \nRe-rendering: Changing state triggers a re-render, so useState updates are reflected immediately in the UI. \nImmutable Updates: Avoid directly modifying arrays or objects; use spread syntax to ensure React detects state changes correctly.",
      "\nSummary \nuseState is essential for handling dynamic, interactive UI elements in React. By tracking and updating component state, you can create responsive, user-friendly components that react to user input and internal changes."
    ],
    "indices": [1, 3, 5, 7, 9, 11],
    "highlightWords": [
      "•",
      "Basic Syntax of",
      "Parameters:",
      "1. state:",
      "2. setState:",
      "3. initialValue:",
      "Example: Counter with useState",
      "Explanation:",
      "Re-rendering:",
      "increment function:",
      "const [count, setCount] = useState(0);:",
      "Example: Handling Form Input with useState",
      "Updating Objects and Arrays with useState",
      "Explanation:",
      "Example: Updating an Object",
      "Example: Updating an Array",
      "Lazy Initialization of useState",
      "Key Points:",
      "State Updates Are Asynchronous:",
      "Re-rendering:",
      "Immutable Updates:",
      "Summary"
    ]
  },
  {
    "id": 9,
    "title": "useEffect",
    "description": [
      "In React, useEffect is a hook that lets you perform side effects in functional components. Side effects include tasks like fetching data, setting up subscriptions, manually updating the DOM, or managing timers. By using useEffect, you can handle these tasks effectively and manage component lifecycle events within a functional component. \n\nBasic Syntax \nTo use useEffect, import it from React and call it within your component:",
      "import React, { useEffect } from 'react';\r\n\r\nfunction ExampleComponent() {\r\n  useEffect(() => {\r\n    // Side effect logic here\r\n\r\n    return () => {\r\n      // Cleanup logic (if needed) here\r\n    };\r\n  }, [dependencies]);\r\n}",
      "\nParameters: \n1. Effect Function: A function that runs your side effect code. \n2. Cleanup Function (Optional): Returned inside the effect function to clean up resources (e.g., clearing timers, removing event listeners). \n3. Dependencies Array (Optional): A list of variables that, when changed, re-run the effect. \n\nWhen useEffect Runs \n• After every render: By default, useEffect runs after every render. \n• Only on mount (initial render): Pass an empty dependency array [] to run the effect only once when the component mounts. \n• When dependencies change: Specify dependencies in the array to re-run the effect only when those values change. \n\nBasic Example: Logging on Every Render \nHere’s an example of an effect that logs a message after every render:",
      "import React, { useEffect, useState } from 'react';\r\n\r\nfunction Logger() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  useEffect(() => {\r\n    console.log(`Rendered with count: ${count}`);\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Logger;",
      "\nExample: Fetching Data on Mount \nTo fetch data only once when the component mounts, you can use an empty dependency array:",
      "import React, { useEffect, useState } from 'react';\r\n\r\nfunction DataFetcher() {\r\n  const [data, setData] = useState([]);\r\n\r\n  useEffect(() => {\r\n    async function fetchData() {\r\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts');\r\n      const data = await response.json();\r\n      setData(data);\r\n    }\r\n    fetchData();\r\n  }, []); // Empty array ensures it runs only on mount\r\n\r\n  return (\r\n    <div>\r\n      <h2>Data:</h2>\r\n      <ul>\r\n        {data.slice(0, 5).map((item) => (\r\n          <li key={item.id}>{item.title}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DataFetcher;",
      "Explanation \n• Empty Dependency Array []: Ensures the effect only runs once on the initial render (component mount). \n• Cleanup: Since there’s no cleanup needed for a fetch request, we don’t return a cleanup function. \n\nExample: Timer with Cleanup \nHere’s an example of using useEffect to set up a timer that increments a counter every second, and then cleans up the timer when the component unmounts:",
      "import React, { useState, useEffect } from 'react';\r\n\r\nfunction Timer() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const interval = setInterval(() => {\r\n      setCount((prevCount) => prevCount + 1);\r\n    }, 1000);\r\n\r\n    // Cleanup function to clear interval on unmount\r\n    return () => clearInterval(interval);\r\n  }, []); // Empty array makes this effect run only on mount\r\n\r\n  return <p>Seconds: {count}</p>;\r\n}\r\n\r\nexport default Timer;",
      "\nExplanation: \nEffect with Cleanup: The setInterval creates a timer that increments the count every second. When the component unmounts, clearInterval(interval) clears the timer, preventing memory leaks. \n\nDependency Array \nThe dependency array controls when the effect re-runs: \n• Empty Array []: The effect runs only once, when the component mounts. \n• Array with Variables: If specific dependencies are included (e.g., [count]), the effect runs whenever any of those dependencies change. \n• No Array: Without any dependency array, the effect will run after every render. \n\nExample: Reacting to State Changes",
      "import React, { useEffect, useState } from 'react';\r\n\r\nfunction CounterWithEffect() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  useEffect(() => {\r\n    console.log(`Count changed to ${count}`);\r\n  }, [count]); \/\/ Only runs when 'count' changes\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}<\/p>\r\n      <button onClick={() => setCount(count + 1)}>Increment<\/button>\r\n    <\/div>\r\n  );\r\n}",
      "In this case, the useEffect only runs when count changes. \n\nSummary: \n• useEffect Hook: Used to handle side effects in functional components. \n• Dependencies Array: Controls when the effect runs and re-runs. \n• Empty Array []: Effect runs only on mount. \n• Specified Dependencies: Effect runs when specified dependencies change. \n• No Array: Effect runs after every render. \n• Cleanup: Use the returned function to clean up resources or subscriptions to prevent memory leaks."
    ],
    "indices": [1, 3, 5, 7, 9],
    "highlightWords": [
      "•",
      "Basic Syntax",
      "Parameters:",
      "1. Effect Function:",
      "2. Cleanup Function (Optional):",
      "3. Dependencies Array (Optional):",
      "When useEffect Runs",
      "After every render:",
      "Only on mount (initial render):",
      "When dependencies change:",
      "Basic Example: Logging on Every Render",
      "Example: Fetching Data on Mount",
      "Explanation",
      "Empty Dependency Array []:",
      "Cleanup:",
      "Example: Timer with Cleanup",
      "Explanation:",
      "Effect with Cleanup:",
      "Dependency Array",
      "Empty Array []:",
      "Array with Variables:",
      "No Array:",
      "Example: Reacting to State Changes",
      "Summary:",
      "useEffect Hook:",
      "Dependencies Array:",
      "Empty Array []:",
      "Specified Dependencies:",
      "No Array:",
      "Cleanup:"
    ]
  },
  {
    "id": 10,
    "title": "useRef",
    "description": [
      "In React, useRef is a hook that creates a mutable object that persists across re-renders. It’s often used for accessing or manipulating DOM elements directly (e.g., focusing on input fields, scrolling), but it can also store any mutable value without triggering a re-render when the value changes. This makes it useful for cases where you need to hold some data across renders without needing it to cause a re-render. \n\nSyntax and Usage \nTo use useRef, import it from React and call it within your functional component:",
      "import React, { useRef } from 'react';\r\n\r\nfunction ExampleComponent() {\r\n  const ref = useRef(initialValue);\r\n  \r\n  // Usage of ref.current\r\n}",
      "\nuseRef for DOM Manipulation \nOne common use case is to access DOM elements directly. When you assign a ref to an element, useRef will create an object with a .current property that points to that DOM element. \n\nExample: Focusing an Input Field",
      "import React, { useRef } from 'react';\r\n\r\nfunction FocusInput() {\r\n  const inputRef = useRef(null); // Initialize ref with null\r\n\r\n  const handleFocus = () => {\r\n    inputRef.current.focus(); // Directly accesses the DOM node to focus the input\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <input ref={inputRef} type=\"text\" placeholder=\"Click the button to focus me\" />\r\n      <button onClick={handleFocus}>Focus Input</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FocusInput;",
      "\nExplanation: \n• const inputRef = useRef(null);: Initializes a ref with null. The inputRef will hold a reference to the <input> element once the component mounts. \n• inputRef.current.focus();: Accesses the actual DOM node and calls the focus method on it when the button is clicked. \n\nuseRef to Store Mutable Values Without Causing Re-renders \nSince useRef persists values between renders and doesn’t cause a re-render when changed, it’s also handy for storing other kinds of mutable data (like a counter or a flag) that you don’t want to trigger re-renders. \n\nExample: Storing a Previous Value",
      "import React, { useRef, useEffect, useState } from 'react';\r\n\r\nfunction PreviousValue() {\r\n  const [count, setCount] = useState(0);\r\n  const prevCountRef = useRef(count); // Create a ref to store previous count\r\n\r\n  useEffect(() => {\r\n    prevCountRef.current = count; // Update ref to the latest count after every render\r\n  }, [count]); // Effect runs whenever count changes\r\n\r\n  return (\r\n    <div>\r\n      <p>Current Count: {count}</p>\r\n      <p>Previous Count: {prevCountRef.current}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default PreviousValue;",
      "\nExplanation: \nconst prevCountRef = useRef(count);: Initializes a ref with the initial value of count. \nUpdating the ref: Inside useEffect, the ref is updated to the latest count value on each render. However, updating prevCountRef.current doesn’t cause a re-render, so it’s great for tracking the previous state. \n\nWhen to Use useRef \nAccessing the DOM directly: For things like focusing, scrolling, or measuring elements without causing a re-render. \nStoring persistent data across renders: Like storing the previous value of a state variable, tracking the number of renders, or setting timers and intervals that don’t affect the UI directly. \n\nExample: Tracking Component Mount Status \nAnother use case for useRef is tracking component mount status. This can be useful to prevent setting state on an unmounted component:",
      "import React, { useState, useRef, useEffect } from 'react';\r\n\r\nfunction AsyncComponent() {\r\n  const [data, setData] = useState(null);\r\n  const isMounted = useRef(true); // Ref to track if component is mounted\r\n\r\n  useEffect(() => {\r\n    // Simulate async operation\r\n    setTimeout(() => {\r\n      if (isMounted.current) {\r\n        setData('Data Loaded'); // Only set state if component is still mounted\r\n      }\r\n    }, 2000);\r\n\r\n    // Cleanup function to mark component as unmounted\r\n    return () => {\r\n      isMounted.current = false;\r\n    };\r\n  }, []);\r\n\r\n  return <div>{data || 'Loading...'}</div>;\r\n}\r\n\r\nexport default AsyncComponent;",
      "\nExplanation: \n• const isMounted = useRef(true);: Initializes a ref to track the mounted status. \n• isMounted.current = false;: In the cleanup function, the ref is set to false when the component unmounts, preventing potential errors by avoiding state updates on an unmounted component. \n\nSummary \n• useRef creates a mutable object with a .current property that persists across re-renders. \n• DOM manipulation: Attach useRef to elements for direct access to DOM nodes without re-renders. \n• Storing values: Track values across renders without causing re-renders, like previous states or flags. \n• Component lifecycle: Check if a component is mounted/unmounted to safely manage async operations. \n\nIn short, useRef is versatile for both DOM manipulations and storing mutable values that shouldn’t trigger component updates."
    ],
    "indices": [1, 3, 5, 7],
    "highlightWords": [
      "•",
      "Syntax and Usage",
      "useRef for DOM Manipulation",
      "Example: Focusing an Input Field",
      "Explanation:",
      "const inputRef = useRef(null);:",
      "inputRef.current.focus();:",
      "useRef to Store Mutable Values Without Causing Re-renders",
      "Example: Storing a Previous Value",
      "const prevCountRef = useRef(count);:",
      "Updating the ref:",
      "When to Use useRef",
      "Accessing the DOM directly:",
      "Storing persistent data across renders:",
      "Example: Tracking Component Mount Status",
      "Summary",
      "DOM manipulation:",
      "Storing values:",
      "Component lifecycle:"
    ]
  },
  {
    "id": 11,
    "title": "useMemo",
    "description": [
      "In React, useMemo is a hook that helps optimize performance by memoizing expensive calculations. When you use useMemo, React will only recompute the memoized value when one of the specified dependencies changes. This prevents unnecessary calculations on every render, making your components faster and more efficient. \n\nSyntax of useMemo \nTo use useMemo, import it from React and call it with a function that performs the calculation and an array of dependencies:",
      "import React, { useMemo } from 'react';\r\n\r\nconst memoizedValue = useMemo(() => {\r\n  // Expensive calculation here\r\n  return computedValue;\r\n}, [dependencies]);",
      "\nParameters 1. Memoized Function: A function that performs the calculation and returns the computed value. 2. Dependencies Array: An array of variables that the calculation depends on. If any dependency changes, useMemo will re-run the function; otherwise, it will return the previously memoized value.",
      "\nWhen to Use useMemo \nuseMemo is ideal when: \n• You have expensive computations (like data processing or calculations) that shouldn't re-run on every render. \n• You want to avoid re-rendering components based on values that haven’t changed. \n\nExample: Expensive Calculation with useMemo \nHere’s an example where a component calculates a factorial, which can be computationally intensive for large numbers:",
      "import React, { useState, useMemo } from 'react';\r\n\r\nfunction ExpensiveCalculationComponent() {\r\n  const [number, setNumber] = useState(1);\r\n  const [count, setCount] = useState(0);\r\n\r\n  // Memoized factorial calculation\r\n  const factorial = useMemo(() => calculateFactorial(number), [number]); \r\n\r\n  function calculateFactorial(n) {\r\n    console.log('Calculating factorial...');\r\n    if (n <= 0) return 1;\r\n    return n * calculateFactorial(n - 1);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <h3>Factorial of {number}: {factorial}</h3>\r\n      <button onClick={() => setNumber((prev) => prev + 1)}>Increment Number</button> \r\n      <button onClick={() => setCount((prev) => prev + 1)}>Increment Count</button> \r\n      <p>Other count: {count}</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default ExpensiveCalculationComponent;",
      "\nExplanation \n• useMemo(() => calculateFactorial(number), [number]);: This memoizes the factorial calculation, so it only re-runs when number changes. This saves processing power by skipping the calculation when count changes. \n• Only Recomputed on Dependency Change: The factorial is only recalculated when number changes, not on every render. \n\nExample: Filtering Data with useMemo \nAnother common use case is optimizing a filtered list, where filtering might be slow for large datasets.",
      "import React, { useState, useMemo } from 'react';\r\n\r\nfunction FilteredList() {\r\n  const [query, setQuery] = useState('');\r\n  const items = ['apple', 'banana', 'orange', 'pear', 'peach'];\r\n\r\n  // Memoized filtered list\r\n  const filteredItems = useMemo(() => {\r\n    console.log('Filtering items...');\r\n    return items.filter((item) => item.toLowerCase().includes(query.toLowerCase())); \r\n  }, [query, items]);\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        value={query}\r\n        onChange={(e) => setQuery(e.target.value)}\r\n        placeholder=\"Search items\"\r\n      />\r\n      <ul>\r\n        {filteredItems.map((item, index) => (\r\n          <li key={index}>{item}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FilteredList;",
      "\nExplanation \nuseMemo for Filtering: The filter operation only runs when query or items changes. This avoids redundant filtering when the component re-renders, improving performance on large datasets.",
      "\nSummary of useMemo \n• Prevents Re-calculation: Only re-calculates the value when dependencies change, improving performance. \n• Memoizes Values: Useful for expensive calculations or large data filtering. \n• Dependency Array: Controls when to recompute the memoized value.",
      "useMemo is valuable when your component needs to process data, calculate values, or filter lists without triggering unnecessary recalculations on every render. This can lead to smoother performance, especially in complex or data-intensive applications."
    ],
    "indices": [1, 4, 6],
    "highlightWords": [
      "•",
      "Syntax of useMemo",
      "Dependency Array:",
      "Memoizes Values:",
      "Prevents Re-calculation:",
      "Summary of useMemo",
      "Parameters",
      "1. Memoized Function:",
      "2. Dependencies Array:",
      "Explanation",
      "useMemo for Filtering:",
      "example:",
      "when to use usememo",
      "usememo is ideal when"
    ]
  },
  {
    "id": 12,
    "title": "useCallback",
    "description": [
      "In React, useCallback is a hook that memoizes a function to prevent it from being recreated on every render. This is particularly useful when passing functions as props to child components, as it helps prevent unnecessary re-renders and optimizes performance. \n\nSyntax of useCallback \nTo use useCallback, import it from React and call it with a function and a dependencies array:",
      "import React, { useCallback } from 'react';\r\n\r\nconst memoizedCallback = useCallback(() => {\r\n  // Callback function logic\r\n}, [dependencies]);",
      "\nParameters \n1. Callback Function: The function to be memoized. \n2. Dependencies Array: A list of variables that the callback depends on. If any of these variables change, the callback will be recreated. \n\nWhen to Use useCallback \nuseCallback is most useful when: \nPassing callback functions to memoized child components to prevent unnecessary re-renders. \nOptimizing event handlers or functions that only need to be redefined when specific dependencies change. \n\nExample: Avoiding Unnecessary Re-renders in a Child Component \nHere’s an example where we use useCallback to prevent a child component from re-rendering unnecessarily.",
      "import React, { useState, useCallback } from 'react';\r\nimport ChildComponent from './ChildComponent';\r\n\r\nfunction ParentComponent() {\r\n  const [count, setCount] = useState(0);\r\n  const [text, setText] = useState('');\r\n\r\n  // Memoized callback function to increment count\r\n  const incrementCount = useCallback(() => {\r\n    setCount((prev) => prev + 1);\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <input type=\"text\" value={text} onChange={(e) => setText(e.target.value)} placeholder=\"Type here\" />\r\n      <ChildComponent onClick={incrementCount} />\r\n      <p>Count: {count}</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default ParentComponent;",
      "Child Component",
      "import React from 'react';\r\n\r\nfunction ChildComponent({ onClick }) {\r\n  console.log('Child rendered');\r\n  return <button onClick={onClick}>Increment Count</button>;\r\n}\r\n\r\nexport default React.memo(ChildComponent);",
      "\nExplanation \n• useCallback: The incrementCount function is memoized, so it doesn’t change on each render of ParentComponent. \n• React.memo in Child Component: Wrapping ChildComponent with React.memo ensures it only re-renders if its props change. Since incrementCount is memoized with useCallback, the child component doesn’t re-render every time the parent component’s state changes. \n\nExample: Event Handler with Dependencies \nHere’s an example where we use useCallback for an event handler that depends on a state variable:",
      "import React, { useState, useCallback } from 'react';\r\n\r\nfunction SearchComponent() {\r\n  const [query, setQuery] = useState('');\r\n\r\n  const handleSearch = useCallback(() => {\r\n    console.log(`Searching for: ${query}`);\r\n  }, [query]); // Re-creates only when 'query' changes\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        value={query}\r\n        onChange={(e) => setQuery(e.target.value)}\r\n        placeholder=\"Search here\"\r\n      />\r\n      <button onClick={handleSearch}>Search</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default SearchComponent;",
      "\nExplanation \nuseCallback with Dependencies: handleSearch is memoized, and it only re-creates when query changes. This prevents unnecessary function re-creation on every render. \n\nSummary of useCallback \n• Prevents Function Re-Creation: Optimizes performance by reusing functions across renders. \n• Useful for Child Components: Avoids unnecessary re-renders when memoized child components rely on callback props. \n• Dependency Array: Controls when to recreate the memoized callback. \n\nUsing useCallback can improve performance, especially when memoized child components depend on callback functions, by keeping them stable across renders. This is particularly helpful in complex applications with deeply nested components."
    ],
    "indices": [1, 3, 5, 7, 9],
    "highlightWords": [
      "•",
      "Syntax of useCallback",
      "Parameters",
      "1. Callback Function:",
      "2. Dependencies Array:",
      "When to Use useCallback",
      "Example: Avoiding Unnecessary Re-renders in a Child Component",
      "Child Component",
      "Explanation",
      "useCallback:",
      "React.memo",
      "Example: Event Handler with Dependencies",
      "Summary of usecallback"
    ]
  },
  {
    "id": 13,
    "title": "Events",
    "description": [
      "In React, events are actions that occur as a result of user interaction or system-generated events, such as clicking a button, typing in an input field, or scrolling. \nReact events are named using camelCase (e.g., onClick, onChange). \nReact event handlers are written inside curly braces: onClick={handleClick}  instead of onclick='handleClick()' \n\nCommon React Events \n1. Mouse Events: \nonClick: Triggered when an element is clicked. \nonDoubleClick: Triggered when an element is double-clicked. \nonMouseEnter: Triggered when the mouse enters an element. \nonMouseLeave: Triggered when the mouse leaves an element. \nonMouseDown: Triggered when the mouse button is pressed. \nonMouseUp: Triggered when the mouse button is released. \n\n2. Keyboard Events: \nonKeyDown: Triggered when a key is pressed down. \nonKeyPress: Triggered when a key is pressed (deprecated in modern browsers, prefer onKeyDown). \nonKeyUp: Triggered when a key is released. \n\n3. Form Events: \nonChange: Triggered when the value of an input or textarea changes. \nonSubmit: Triggered when a form is submitted. \nonFocus: Triggered when an element gains focus. \nonBlur: Triggered when an element loses focus. \n\n4. Touch Events: \nonTouchStart: Triggered when a finger touches the screen. \nonTouchMove: Triggered when a finger moves on the screen. \nonTouchEnd: Triggered when a finger is lifted from the screen. \n\n5. Window Events: \nonScroll: Triggered when an element is scrolled. \nonResize: Triggered when the window is resized. \n\nExample: Handling a Click Event \nHere's how you handle a click event in React:",
      "import React from 'react'; \nfunction ClickButton() { \n function handleClick() { \n   alert('Button clicked!'); \n } \n return (\n   <button onClick={handleClick}>Click me</button>; \n )\n} \nexport default ClickButton;",
      "In this example: \nonClick={handleClick} binds the handleClick function to the button's click event. When the button is clicked, the handleClick function will be executed, showing an alert message. \n\nPreventing Default Behavior \nYou can prevent the default behavior of events (e.g., submitting a form) using the event.preventDefault() method:",
      "function SubmitForm() { \n function handleSubmit(event) { \n  event.preventDefault(); // Prevents the form from being submitted \n  alert('Form submitted'); \n } \n return ( \n  <form onSubmit={handleSubmit}> \n   <button type='submit'>Submit</button> \n  </form> \n ); \n}"
    ],
    "indices": [1, 3],
    "highlightWords": [
      "common react events",
      "1. Mouse events:",
      "onclick:",
      "ondoubleclick:",
      "onmouseenter:",
      "onmouseleave:",
      "onmousedown:",
      "onmouseup:",
      "2. keyboard events",
      "onkeydown:",
      "onkeyup:",
      "onkeypress:",
      "3. form events:",
      "onchange:",
      "onsubmit:",
      "onfocus:",
      "onblur:",
      "4. touch events:",
      "ontouchstart:",
      "ontouchmove:",
      "ontouchend:",
      "5. window events:",
      "onscroll:",
      "onresize:",
      "example:",
      "onclick={handleclick}",
      "onclick='handleclick()'",
      "preventing default behavior"
    ]
  },
  {
    "id": 14,
    "title": "Conditional Rendering",
    "description": [
      "In React, conditional rendering allows you to render different components or elements based on specific conditions. It works similarly to JavaScript conditions using if, else, ternary operators, or logical operators, enabling dynamic and flexible UI updates. \n\nHere are some common techniques for conditional rendering in React: \n\n1. Using if Statements \nThe most straightforward way to conditionally render a component is using a JavaScript if statement within the render method or a functional component. \n\nExample:",
      "function UserGreeting(props) { \n const isLoggedIn = props.isLoggedIn; \n if (isLoggedIn) { \n  return <h1>Welcome back!</h1>; \n } \n return <h1>Please sign up.</h1>; \n}",
      "In this example: \nIf isLoggedIn is true, the message 'Welcome back!' is rendered. Otherwise, 'Please sign up.' is displayed. \n\n2. Ternary Operator \nA more concise way to achieve conditional rendering is to use the ternary operator (condition ? exprIfTrue : exprIfFalse). \n\nExample:",
      "function UserGreeting(props) { \n return (\n  props.isLoggedIn ? \n   <h1>Welcome back!</h1> : \n   <h1>Please sign up.</h1>\n ); \n}",
      "In this case, the ternary operator directly evaluates whether the user is logged in and renders the appropriate message. \n\n3. Logical && Operator \nYou can also use the logical AND (&&) operator to render a component only when a condition is true. If the condition is false, React skips the component. \n\nExample:",
      "function Notifications(props) { \n const hasNotifications = props.hasNotifications; \n return ( \n  <div> \n   {hasNotifications && \n    <h2>You have new notifications!</h2>\n   } \n   <p>Other content...</p> \n  </div> \n ); \n}",
      "In this example, if hasNotifications is true, the <h2> element will be rendered. If it's false, React will skip the <h2> element and continue rendering the rest of the component."
    ],
    "indices": [1, 3, 5],
    "highlightWords": [
      "Here are some common techniques for conditional rendering in React:",
      "1. Using if Statements",
      "Example:",
      "2. Ternary Operator",
      "3. Logical && Operator"
    ]
  }
]
