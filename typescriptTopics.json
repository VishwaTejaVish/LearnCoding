[
  {
    "id": 1,
    "title": "What is Typescript?",
    "description": "TypeScript is a programming language developed and maintained by Microsoft. It’s a superset of JavaScript, meaning it builds on JavaScript by adding additional features, mainly static typing. Here’s a quick breakdown of what makes TypeScript unique: \n\n1. Static Typing: TypeScript introduces static types to JavaScript. This allows developers to define variable types (e.g., number, string, boolean, custom types) explicitly, which helps catch errors at compile time rather than runtime, reducing bugs and improving code quality. \n\n2. Compile-Time Error Checking: TypeScript code is compiled to JavaScript, so any errors or type mismatches are caught during compilation. This improves the development experience and avoids some common JavaScript runtime errors. \n\n3. Enhanced IDE Support: TypeScript is well-integrated with IDEs like Visual Studio Code. It provides features like autocompletion, navigation, and refactoring tools, which make development smoother. \n\n4. Supports Modern JavaScript Features: TypeScript includes the latest JavaScript features (e.g., async/await, destructuring, modules) and compiles them down to compatible JavaScript, making it easier to use modern language features while supporting older environments. \n\n5. Interfaces and Enums: TypeScript adds additional structures, like interfaces and enums, that help with organizing code and defining structures for objects, making it more suitable for large-scale applications. \n\nBecause of these benefits, TypeScript is widely used for building large-scale web applications where code maintainability, readability, and safety are essential. It’s especially popular in frameworks like Angular and React.",
    "highlightWords": [
      "1. Static Typing:",
      "2. Compile-Time Error Checking:",
      "3. Enhanced IDE Support:",
      "4. Supports Modern JavaScript Features:",
      "5. Interfaces and Enums:"
    ]
  },
  {
    "id": 2,
    "title": "Data Types",
    "description": [
      "TypeScript has a variety of data types that allow you to define and enforce structure in your code. Here’s an overview of the primary data types: \n\n1. Primitive Types \nnumber: Represents both integer and floating-point numbers.",
      "let age: number = 25;",
      "string: Represents text data.",
      "let name: string = \"Alice\";",
      "boolean: Represents true or false values.",
      "let isActive: boolean = true;",
      "null and undefined: Special types for values that are empty or not initialized.",
      "let emptyValue: null = null;\r\nlet notInitialized: undefined = undefined;",
      "\n2. Any Type \nany: Allows any type of value, disabling type-checking for that variable.",
      "let variable: any = \"Hello\";\r\nvariable = 42;",
      "\n3. Unknown Type \nunknown: Represents a value that could be any type but requires a type check before being used, offering safer typing than any.",
      "let uncertain: unknown = \"Hello\";\r\nif (typeof uncertain === \"string\") {\r\n  console.log(uncertain.toUpperCase());\r\n}",
      "\n4. Void Type \nvoid: Used to indicate that a function does not return a value.",
      "function logMessage(message: string): void {\r\n  console.log(message);\r\n}",
      "\n5. Never Type \nnever: Represents a value that never occurs, typically used for functions that throw errors or run indefinitely.",
      "function error(message: string): never {\r\n  throw new Error(message);\r\n}",
      "\n6. Arrays \nArray: Can be defined using type[] or Array<type>.",
      "let numbers: number[] = [1, 2, 3];\r\nlet strings: Array<string> = [\"a\", \"b\", \"c\"];",
      "\n7. Tuple \ntuple: A fixed-length array where each element has a specific type.",
      "let person: [string, number] = [\"Alice\", 25];",
      "\n8. Enums \nenum: A way to define a set of named constants.",
      "enum Color {\r\n  Red,\r\n  Green,\r\n  Blue,\r\n}\r\nlet myColor: Color = Color.Green;",
      "\n9. Object \nobject: Represents a non-primitive type (i.e., not number, string, boolean, null, or undefined).",
      "let user: { name: string; age: number } = { name: \"Alice\", age: 25 };",
      "\n10. Union Types \nunion: Allows a variable to hold values of different types.",
      "let id: number | string;\r\nid = 101; // valid\r\nid = \"ABC\"; // also valid",
      "\n11. Literal Types \nliteral: Allows a variable to hold a specific value or set of values.",
      "let direction: \"up\" | \"down\";\r\ndirection = \"up\"; // valid\r\ndirection = \"down\"; // valid",
      "\n12. Type Aliases \ntype alias: A custom type that can represent primitives, unions, or other types.",
      "type StringOrNumber = string | number;\r\nlet data: StringOrNumber = \"Hello\";",
      "\n13. Function Types \nDescribes the input and output types of a function.",
      "let add: (x: number, y: number) => number;\r\nadd = (x, y) => x + y;",
      "\n14. Interfaces \nDefines the structure of an object type, often used for complex data structures.",
      "interface User {\r\n  name: string;\r\n  age: number;\r\n  isActive?: boolean; // optional property\r\n}\r\nlet user: User = { name: \"Alice\", age: 25 };",
      "\nUnderstanding these data types helps to build type-safe applications that are easier to debug and maintain, making TypeScript especially valuable for large codebases."
    ],
    "indices": [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33],
    "highlightWords": [
      "1. Primitive Types",
      "number:",
      "string:",
      "boolean:",
      "null",
      "undefined:",
      "2. Any Type",
      "any:",
      "3. Unknown Type",
      "unknown:",
      "4. Void Type",
      "void:",
      "5. Never Type",
      "never:",
      "6. Arrays",
      "Array:",
      "7. Tuple",
      "tuple:",
      "8. Enums",
      "enum:",
      "9. Object",
      "object:",
      "10. Union Types",
      "union:",
      "11. Literal Types",
      "literal:",
      "12. Type Aliases",
      "type alias:",
      "13. Function Types",
      "14. Interfaces"
    ]
  },
  {
    "id": 3,
    "title": "Functions",
    "description": [
      "In TypeScript, functions are essential, and the language provides enhanced support for defining function types and adding stricter type-checking. Here's a breakdown of how to work with functions in TypeScript:",
      "\n1. Basic Function Syntax \nDefine function parameter types and return types. If no return type is specified, TypeScript infers it.",
      "function add(x: number, y: number): number {\r\n  return x + y;\r\n}",
      "\n2. Function Expressions \nYou can define functions as expressions and assign them to variables. TypeScript will infer the types.",
      "const multiply = function (x: number, y: number): number {\r\n  return x * y;\r\n};",
      "\n3. Arrow Functions \nArrow functions are commonly used for shorter syntax. Types are defined in the same way as in regular functions.",
      "const divide = (x: number, y: number): number => x / y;",
      "\n4. Optional Parameters \nUse ? to mark a parameter as optional.",
      "function greet(name: string, greeting?: string): string {\r\n  return `${greeting || \"Hello\"}, ${name}!`;\r\n}\r\ngreet(\"Alice\"); // \"Hello, Alice!\"\r\ngreet(\"Bob\", \"Hi\"); // \"Hi, Bob!\"",
      "\n5. Default Parameters \nYou can assign default values to parameters.",
      "function power(base: number, exponent: number = 2): number {\r\n  return Math.pow(base, exponent);\r\n}\r\npower(3); // 9 (3^2)\r\npower(3, 3); // 27 (3^3)",
      "\n6. Rest Parameters \nUse rest parameters to handle multiple arguments as an array.",
      "function sum(...numbers: number[]): number {\r\n  return numbers.reduce((acc, curr) => acc + curr, 0);\r\n}\r\nsum(1, 2, 3, 4); // 10",
      "\n7. Function Types \nYou can explicitly define a function’s type signature for both parameters and return type.",
      "let calculate: (x: number, y: number) => number; calculate = (a, b) => a + b; // function must match the signaturelet calculate: (x: number, y: number) => number; calculate = (a, b) => a + b; // function must match the signature",
      "\n8. Function Overloading \nTypeScript allows function overloading, where multiple function signatures can be defined for a single function, letting it handle different parameter types.",
      "function getInfo(value: string): string;\r\nfunction getInfo(value: number): number;\r\nfunction getInfo(value: string | number): string | number {\r\n  if (typeof value === \"string\") {\r\n    return `Name: ${value}`;\r\n  } else {\r\n    return `Age: ${value}`;\r\n  }\r\n}",
      "\n9. Void Return Type \nThe void type is used when a function does not return any value.",
      "function logMessage(message: string): void {\r\n  console.log(message);\r\n}",
      "\n10. Never Return Type \nThe never type is used for functions that never return, typically due to an infinite loop or exception.",
      "function throwError(message: string): never {\r\n  throw new Error(message);\r\n}",
      "\n11. this Parameter \nTypeScript allows specifying the type of this in a function, useful in class methods and callbacks.",
      "class Counter {\r\n  count: number = 0;\r\n  increment(this: Counter) {\r\n    this.count++;\r\n  }\r\n}\r\nconst counter = new Counter();\r\ncounter.increment();",
      "\n12. Anonymous Functions \nOften used as callbacks, anonymous functions in TypeScript still allow for type-checking parameters.",
      "const numbers = [1, 2, 3];\r\nnumbers.forEach((num: number) => console.log(num * 2));",
      "\n13. Returning Functions \nFunctions can return other functions, and TypeScript allows for typing this behavior.",
      "function createMultiplier(factor: number): (x: number) => number {\r\n  return (x: number) => x * factor;\r\n}\r\nconst double = createMultiplier(2);\r\ndouble(5); // 10",
      "\n14. Callable Interfaces \nYou can define function types using interfaces for cases where a function may have additional properties.",
      "interface GreetingFunction {\r\n  (name: string): string;\r\n  description: string;\r\n}\r\n\r\nconst greet: GreetingFunction = (name: string) => `Hello, ${name}`;\r\ngreet.description = \"A simple greeting function\";",
      "\nMastering these patterns in TypeScript allows you to define functions with clear and strict type contracts, making your code more readable, maintainable, and bug-resistant."
    ],
    "indices": [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
    "highlightWords": [
      "1. Basic Function Syntax",
      "2. Function Expressions",
      "3. Arrow Functions",
      "4. Optional Parameters",
      "5. Default Parameters",
      "6. Rest Parameters",
      "14. Callable Interfaces",
      "13. Returning Functions",
      "12. Anonymous Functions",
      "11. this Parameter",
      "10. Never Return Type",
      "9. Void Return Type",
      "8. Function Overloading",
      "7. Function Types"
    ]
  }
]
