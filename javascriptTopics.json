[
  {
    "id": 1,
    "title": "What is Javacript",
    "description": "JavaScript is a high-level, dynamic programming language primarily used for web development. \nIt allows developers to create interactive and dynamic content on websites, such as animations, form validations, games, and real-time updates. \nIt works alongside HTML (which structures a webpage) and CSS (which styles a webpage) to enhance user experiences. \n\nHere are some key features of JavaScript: \n\nClient-Side Scripting: \nJavaScript is mainly executed in the browser (client-side), allowing web pages to respond to user interactions without needing to reload the page. \n\nInteractivity: \nJavaScript can manipulate the HTML and CSS of a webpage, making it possible to update content, animate elements, handle user input, and create interactive features. \n\nEvent-Driven: \nJavaScript is designed to react to user actions (events) like clicks, form submissions, and keystrokes. \n\nVersatile: \nWhile traditionally used for web development, JavaScript can also be used on servers (with Node.js), in mobile applications, game development, and more. \n\nRich Ecosystem: \nIt has a large community, numerous libraries (e.g., React, Angular, Vue.js), and frameworks that extend its functionality, making it one of the most popular programming languages today.",
    "highlightWords": [
      "client-side scripting:",
      "interactivity:",
      "event-driven:",
      "versatile:",
      "rich ecosystem:",
      "here are some key features of javascript:"
    ]
  },
  {
    "id": 2,
    "title": "Variables",
    "description": "In JavaScript, variables are used to store data values that can be referenced and manipulated throughout a program. You can think of a variable as a container for storing information. \n\nWays to Declare Variables: \nvar: \nThe original way to declare variables in JavaScript. \nHas function scope, meaning it is accessible throughout the entire function in which it's declared. \nIf declared outside a function, it's globally scoped. \nCan be redeclared within the same scope. \n\nlet: \nIntroduced in ES6 (ECMAScript 2015). \nHas block scope, meaning it is only accessible within the block (enclosed in {}) where it's declared. \nCannot be redeclared in the same scope. \n\nconst: \nAlso introduced in ES6. \nLike let, it has block scope. \nHowever, variables declared with const cannot be reassigned after their initial value is set. \nUseful for variables that should remain constant. \n\nVariable Naming Rules: \nVariable names can include letters, numbers, underscores, and dollar signs. \nThey must begin with a letter, underscore (_), or dollar sign ($). \nJavaScript is case-sensitive, so myVariable and MyVariable are different variables.",
    "highlightWords": [
      "ways to declare variables:",
      "let:",
      "const:",
      "var:",
      "variable naming rules:"
    ]
  },
  {
    "id": 3,
    "title": "Data Types",
    "description": "JavaScript has several data types that represent the different kinds of values that can be stored and manipulated in a program. \nThese are broadly classified into primitive types and non-primitive (reference) types. \n\n1.Primitive Data Types: \nThese are the basic data types in JavaScript and represent single values. They are immutable, meaning their values cannot be altered once assigned. \n\nNumber: \nRepresents both integer and floating-point numbers. \n\nString: \nUsed to represent textual data. Strings are enclosed in single double quotes. \n\nBoolean: \nRepresents one of two values: true or false. Often used in conditional testing. \n\nUndefined: \nA variable that has been declared but not assigned a value is of type undefined. \n\nNull: \nRepresents the intentional absence of any object value. It is used to indicate 'no value.' \n\nSymbol (Introduced in ES6): \nA unique and immutable value, often used to create unique object property keys. \nBigInt (Introduced in ES2020): \nUsed to represent integers larger than the Number type can handle. \n\n2.Non-Primitive (Reference) Data Types: \nThese are data types that are more complex, and they refer to objects that may have properties and methods. \n\nObject: \nA collection of key-value pairs. An object can contain multiple properties and functions (methods). \n\nArray: \nA special type of object used to store ordered lists of values. \n\nFunctions: \nFunctions are also treated as objects in JavaScript, allowing them to be assigned to variables, passed as arguments, or returned from other functions. \n\nType Checking: \nTo check the type of a variable, you can use the typeof operator",
    "highlightWords": [
      "1.primitive data types:",
      "number:",
      "string:",
      "boolean:",
      "undefined:",
      "null:",
      "symbol (introduced in es6):",
      "2.non-primitive (reference) data types:",
      "object:",
      "array:",
      "functions:",
      "type checking:"
    ]
  },
  {
    "id": 4,
    "title": "Strings",
    "description": [
      "In JavaScript, strings are sequences of characters used to represent text. Strings are immutable, meaning once they’re created, they can’t be modified, but new strings can be created based on operations on existing ones. Strings can be created using single quotes (' ') double quotes (\" \"), or template literals/backticks (` `).",
      "Creating Strings \n1. Using Single or Double Quotes:",
      "const singleQuoteString = 'Hello, world!';\r\nconst doubleQuoteString = \"Hello, world!\";",
      "2. Using Template Literals: \nTemplate literals (backticks) allow for multi-line strings and string interpolation (embedding expressions).",
      "const name = \"Alice\";\r\nconst greeting = `Hello, ${name}!`;\r\nconsole.log(greeting); // Output: Hello, Alice!",
      "\nCommon String Methods \n1. length: Returns the number of characters in a string.",
      "const str = \"Hello\";\r\nconsole.log(str.length); // Output: 5",
      "2. charAt(): Returns the character at a specified index.",
      "console.log(str.charAt(1)); // Output: e",
      "3. toUpperCase() and toLowerCase(): Converts the string to upper or lower case.",
      "console.log(str.toUpperCase()); // Output: HELLO\r\nconsole.log(str.toLowerCase()); // Output: hello",
      "4. indexOf() and lastIndexOf(): Finds the position of a specified value; returns -1 if not found.",
      "const sentence = \"The quick brown fox jumps over the lazy dog.\";\r\nconsole.log(sentence.indexOf(\"fox\")); // Output: 16\r\nconsole.log(sentence.lastIndexOf(\"the\")); // Output: 31",
      "5. includes(): Checks if a string contains a specified value.",
      "console.log(sentence.includes(\"fox\")); // Output: true",
      "6. startsWith() and endsWith(): Checks if a string starts or ends with a specified value.",
      "console.log(sentence.startsWith(\"The\")); // Output: true\r\nconsole.log(sentence.endsWith(\"dog.\"));  // Output: true",
      "7. slice(): Extracts a section of a string and returns it as a new string.",
      "console.log(sentence.slice(4, 9)); // Output: quick",
      "8. substring() and substr(): \nsubstring(start, end): Extracts characters from start to end (non-inclusive). \nsubstr(start, length): Extracts characters from start for a specified length.",
      "console.log(sentence.substring(4, 9)); // Output: quick\r\nconsole.log(sentence.substr(4, 5));    // Output: quick",
      "9. replace(): Replaces part of a string with another value. By default, replaces only the first occurrence.",
      "const newSentence = sentence.replace(\"fox\", \"cat\");\r\nconsole.log(newSentence); // Output: The quick brown cat jumps over the lazy dog.",
      "10. replaceAll(): Replaces all occurrences of a substring.",
      "const repeated = \"This is a test test.\";\r\nconsole.log(repeated.replaceAll(\"test\", \"example\")); // Output: This is a example example.",
      "11. trim(), trimStart(), and trimEnd(): \nThe trim() method removes whitespace from both sides of a string. \nThe trimStart() method removes whitespace from the beginning of a string. \nThe trimEnd() method removes whitespace from the end of a string.",
      "const str = \"   hello!    \"\r\nconsole.log(str.trim())      // Output: hello!    \r\nconsole.log(str.trimStart()) // Output: hello!    \r\nconsole.log(str.trimEnd())   // Output:    hello!",
      "12. split(): Splits a string into an array based on a specified separator.",
      "const words = sentence.split(\" \");\r\nconsole.log(words); // Output: [\"The\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog.\"]",
      "13. concat(): Joins two or more strings.",
      "const greeting = \"Hello\";\r\nconst name = \"Alice\";\r\nconsole.log(greeting.concat(\", \", name, \"!\")); // Output: Hello, Alice!",
      "\nString Template Literals and Interpolation \nTemplate literals allow embedding expressions inside strings using ${expression} syntax. \n\nExample:",
      "const firstName = \"John\";\r\nconst lastName = \"Doe\";\r\nconst fullName = `${firstName} ${lastName}`;\r\nconsole.log(`Hello, ${fullName}!`); // Output: Hello, John Doe!",
      "\nTemplate literals also allow multi-line strings:",
      "const multiLineString = `This is a\r\nmulti-line\r\nstring.`;\r\nconsole.log(multiLineString);",
      "\nEscape Characters \nJavaScript supports escape characters for special characters like quotes, newlines, tabs, etc. \n\\n: New line\r\n\\t: Tab\r\n\\\\: Backslash\r\n\\': Single quote\r\n\\\": Double quote \n\nExample:",
      "const escapedString = \"This is a new line:\\nAnd a tab:\\tEnd.\";\r\nconsole.log(escapedString);",
      "Converting Other Data Types to Strings",
      "1. String() function:",
      "const num = 123;\r\nconst numString = String(num); // \"123\"",
      "2. toString() method:",
      "const bool = true;\r\nconst boolString = bool.toString(); // \"true\"",
      "\nString Iteration \nJavaScript strings can be iterated over using a for...of loop.",
      "const str = \"Hello\";\r\nfor (const char of str) {\r\n    console.log(char); // Outputs each character in \"Hello\"\r\n}",
      "\nSummary \n• Strings in JavaScript are immutable sequences of characters. \n• You can create strings with single quotes, double quotes, or template literals (backticks). \n• String methods like slice(), replace(), split(), and toUpperCase() offer versatile ways to manipulate and analyze text. \n• Template literals allow embedding expressions and creating multi-line strings easily."
    ],
    "indices": [
      2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 39,
      41, 43
    ],
    "highlightWords": [
      "•",
      "Creating Strings",
      "1. Using Single or Double Quotes:",
      "2. Using Template Literals:",
      "Common String Methods",
      "1. length:",
      "2. charAt():",
      "3. toUpperCase()",
      "toLowerCase():",
      "4. indexOf()",
      "lastIndexOf():",
      "5. includes():",
      "6. startsWith()",
      "endsWith():",
      "7. slice():",
      "8. substring()",
      "substr():",
      "substring(start, end):",
      "substr(start, length):",
      "9. replace():",
      "10. replaceAll():",
      "12. split():",
      "13. concat():",
      "String Template Literals and Interpolation",
      "Example:",
      "Escape Characters",
      "\n:",
      "\t:",
      "\\:",
      "\\':",
      "\":",
      "Converting Other Data Types to Strings",
      "1. String() function:",
      "toString() method:",
      "String Iteration",
      "Summary",
      "Converting Other Data Types to Strings"
    ]
  },
  {
    "id": 5,
    "title": "Arrays",
    "description": [
      "In JavaScript, arrays are data structures used to store multiple values in a single variable. Arrays can hold values of any data type (numbers, strings, objects, other arrays, etc.) and are zero-indexed, meaning the first element is accessed with index 0",
      "Creating an Array \nYou can create an array in JavaScript in several ways: \n\n1. Using Array Literals (most common):",
      "const fruits = [\"apple\", \"banana\", \"cherry\"];",
      "2. Using the Array Constructor:",
      "const fruits = new Array(\"apple\", \"banana\", \"cherry\");",
      "3. Empty Array:",
      "const emptyArray = [];",
      "4. Array with Specified Length:",
      "const arrayWithLength = new Array(5); // Creates an array with 5 empty slots",
      "\nAccessing and Modifying Array Elements \nYou can access an element in an array using its index:",
      "const fruits = [\"apple\", \"banana\", \"cherry\"];\r\nconsole.log(fruits[1]); // Output: banana",
      "To modify an element:",
      "fruits[1] = \"blueberry\";\r\nconsole.log(fruits); // Output: [\"apple\", \"blueberry\", \"cherry\"] ",
      "\nArray Properties and Methods \n\nBasic Properties \nlength: Returns the number of elements in an array",
      "const fruits = [\"apple\", \"banana\", \"cherry\"];\r\nconsole.log(fruits.length); // Output: 3",
      "\nCommon Array Methods \n1. push(): Adds one or more elements to the end of the array.",
      "fruits.push(\"orange\"); console.log(fruits); // Output: [\"apple\", \"banana\", \"cherry\", \"orange\"] ",
      "2. pop(): Removes the last element of the array.",
      "fruits.pop(); console.log(fruits); // Output: [\"apple\", \"banana\", \"cherry\"] ",
      "3. shift(): Removes the first element of the array.",
      "fruits.shift();\r\nconsole.log(fruits); // Output: [\"banana\", \"cherry\"] ",
      "4. unshift(): Adds one or more elements to the beginning of the array.",
      "fruits.unshift(\"grape\");\r\nconsole.log(fruits); // Output: [\"grape\", \"banana\", \"cherry\"] ",
      "5. splice(): Adds or removes elements from the array at a specific index.",
      "fruits.splice(1, 1, \"kiwi\", \"mango\"); // At index 1, remove 1 element, add \"kiwi\" and \"mango\" \r\nconsole.log(fruits);  // Output: [\"grape\", \"kiwi\", \"mango\", \"cherry\"] ",
      "6. slice(): Returns a new array with selected elements.",
      "const selectedFruits = fruits.slice(1, 3); // From index 1 up to, but not including, index 3 \r\nconsole.log(selectedFruits);  // Output: [\"banana\", \"cherry\"] ",
      "7. concat(): Combines two or more arrays.",
      "const moreFruits = [\"pear\", \"pineapple\"];\r\nconst allFruits = fruits.concat(moreFruits);\r\nconsole.log(allFruits); // Output: [\"apple\", \"banana\", \"cherry\", \"pear\", \"pineapple\"] ",
      "8. join(): Joins all elements of an array into a string, separated by a specified separator.",
      "console.log(fruits.join(\", \")); // Output: \"apple, banana, cherry\" ",
      "9. indexOf() and lastIndexOf(): Find the first and last index of an element in the array.",
      "console.log(fruits.indexOf(\\\"banana\\\")); // Output: 1 \r\nconst a = [\"banana\", \"apple\",\" pear\",\"banana\"]\r\nconsole.log(a.lastIndexOf(\"banana\")) // Output: 3",
      "10. includes(): Checks if an element exists in the array.",
      "console.log(fruits.includes(\"cherry\")); // Output: true ",
      "\nIterating Through Arrays \n1. for Loop:",
      "for (let i = 0; i < fruits.length; i++) {\r\n    console.log(fruits[i]);\r\n}",
      "2. forEach(): Executes a provided function for each element in the array.",
      "fruits.forEach(fruit => console.log(fruit));",
      "3. map(): Creates a new array with the results of applying a function to each element.",
      "const uppercasedFruits = fruits.map(fruit => fruit.toUpperCase());\r\nconsole.log(uppercasedFruits); // Output: [\"APPLE\", \"BANANA\", \"CHERRY\"] ",
      "4. filter(): Creates a new array with elements that pass a test (return true in the callback).",
      "const fruitsWithA = fruits.filter(fruit => fruit.includes(\"a\"));\r\nconsole.log(fruitsWithA); // Output: [\"apple\", \"banana\"]",
      "5. reduce(): Reduces the array to a single value by applying a function to each element and an accumulator.",
      "const numbers = [1, 2, 3, 4];\r\nconst sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\r\nconsole.log(sum); // Output: 10",
      "6. find(): Returns the first element that satisfies a condition.",
      "const foundFruit = fruits.find(fruit => fruit.includes(\"a\"));\r\nconsole.log(foundFruit); // Output: \"apple\"",
      "7. some() and every(): Check if at least one element (some()) or all elements (every()) satisfy a condition.",
      "console.log(fruits.some(fruit => fruit.startsWith(\"b\"))); // Output: true\r\nconsole.log(fruits.every(fruit => typeof fruit === \"string\")); // Output: true ",
      "\nMultidimensional Arrays \nJavaScript allows arrays to contain other arrays, creating multidimensional arrays. \n\nExample:",
      "const matrix = [\r\n    [1, 2, 3],\r\n    [4, 5, 6],\r\n    [7, 8, 9]\r\n];\r\nconsole.log(matrix[1][2]); // Output: 6",
      "\nArray Destructuring \nJavaScript supports array destructuring, which allows you to unpack values from arrays into individual variables. \n\nExample:",
      "const [first, second, third] = fruits;\r\nconsole.log(first);  // Output: apple\r\nconsole.log(second); // Output: banana",
      "\nSpread Operator and Arrays \nThe spread operator (...) allows you to expand an array's elements. \n\nExample:",
      "const fruits = [\"apple\", \"banana\"];\r\nconst moreFruits = [\"cherry\", ...fruits];\r\nconsole.log(moreFruits); // Output: [\"cherry\", \"apple\", \"banana\"] ",
      "\nSorting Arrays \nJavaScript arrays come with a sort() method to sort elements, and you can provide a custom sorting function. \n\nExample:",
      "const numbers = [4, 2, 5, 1, 3];\r\nnumbers.sort((a, b) => a - b); // Ascending order\r\nconsole.log(numbers); // Output: [1, 2, 3, 4, 5]",
      "\nChecking if a Value is an Array \nUse Array.isArray() to check if a value is an array. \n\nExample:",
      "console.log(Array.isArray(fruits)); // Output: true\r\nconsole.log(Array.isArray(\"apple\")); // Output: false ",
      "\nSummary \n• Arrays in JavaScript are versatile and can contain elements of any data type. \n• Common methods include push(), pop(), map(), filter(), and reduce(). \n• Arrays can be multidimensional and can be destructured for easy access. \n• The spread operator (...) and Array methods like sort(), find(), and forEach() make array manipulation more powerful and flexible."
    ],
    "indices": [
      2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
      40, 42, 44, 46, 48, 50, 52, 54, 56, 58
    ],
    "highlightWords": [
      "•",
      "Creating an Array",
      "1. Using Array Literals",
      "2. Using the Array Constructor:",
      "3. Empty Array:",
      "4. Array with Specified Length:",
      "Accessing and Modifying Array Elements",
      "Array Properties and Methods",
      "Basic Properties",
      "length: ",
      "Common Array Methods",
      "1. push():",
      "2. pop():",
      "3. shift():",
      "4. unshift():",
      "5. splice():",
      "6. slice():",
      "7. concat():",
      "8. join():",
      "9. indexOf()",
      "lastIndexOf():",
      "10. includes():",
      "Iterating Through Arrays",
      "1. for Loop:",
      "2. forEach():",
      "3. map():",
      "4. filter():",
      "5. reduce():",
      "6. find():",
      "7. some()",
      "every():",
      "Multidimensional Arrays",
      "Example:",
      "Array Destructuring",
      "Spread Operator and Arrays",
      "Sorting Arrays",
      "Checking if a Value is an Array",
      "Summary"
    ]
  },
  {
    "id": 6,
    "title": "Objects",
    "description": [
      "In JavaScript, objects are collections of key-value pairs used to store related data and functionality. Objects are one of the fundamental data structures in JavaScript and allow for structured data organization. Keys are strings or Symbols, and values can be of any type, including numbers, strings, arrays, functions, or even other objects.",
      "\nCreating an Object \n1. Using Object Literals (most common way):",
      "const person = {\r\n    name: \"Alice\",\r\n    age: 25,\r\n    isStudent: true\r\n};",
      "2. Using the new Object() Constructor:",
      "const person = new Object();\r\nperson.name = \"Alice\";\r\nperson.age = 25;",
      "3. Using the Object.create() Method:",
      "const personPrototype = {\r\n    greet() {\r\n        console.log(`Hello, my name is ${this.name}`);\r\n    }\r\n};\r\nconst person = Object.create(personPrototype);\r\nperson.name = \"Alice\";",
      "\nAccessing Object Properties \nYou can access object properties using dot notation or bracket notation. \n1. Dot Notation:",
      "console.log(person.name); // Output: Alice",
      "2. Bracket Notation (useful for dynamic keys or keys with special characters):",
      "console.log(person[\"age\"]); // Output: 25",
      "\nModifying Object Properties \nYou can add, update, or delete properties in an object. \nAdd or Update a Property:",
      "person.isStudent = false; // Updates the isStudent property \r\nperson.city = \"New York\"; // Adds a new property ",
      "Delete a Property:",
      "delete person.age;\r\nconsole.log(person); // Output: { name: \"Alice\", isStudent: false, city: \"New York\" } ",
      "\nMethods in Objects \nA method is a function defined as a property of an object. \n\nExample:",
      "const person = {\r\n    name: \"Alice\",\r\n    greet() {\r\n        console.log(`Hello, my name is ${this.name}`);\r\n    }\r\n};\r\n\r\nperson.greet(); // Output: Hello, my name is Alice",
      "\nthis Keyword in Objects \nIn an object method, this refers to the object itself, allowing access to other properties or methods of the same object.",
      "const car = {\r\n    brand: \"xyc\",\r\n    model: \"abc\",\r\n    getFullName() {\r\n        return `${this.brand} ${this.model}`;\r\n    }\r\n};\r\n\r\nconsole.log(car.getFullName()); // Output: xyc abc ",
      "\nLooping Through Object Properties \n1. for...in Loop:",
      "for (let key in person) {\r\n    console.log(key, person[key]);\r\n}",
      "2. Object.keys(): Returns an array of an object’s keys.",
      "const keys = Object.keys(person);\r\nconsole.log(keys); // Output: [\"name\", \"isStudent\", \"city\"] ",
      "3. Object.values(): Returns an array of an object’s values.",
      "const values = Object.values(person);\r\nconsole.log(values); // Output: [\"Alice\", false, \"New York\"] ",
      "4. Object.entries(): Returns an array of key-value pairs.",
      "const entries = Object.entries(person);\r\nconsole.log(entries); // Output: [[\"name\", \"Alice\"], [\"isStudent\", false], [\"city\", \"New York\"]] ",
      "\nNested Objects \nObjects can contain other objects as values, allowing for complex data structures.",
      "const student = {\r\n    name: \"Alice\",\r\n    age: 25,\r\n    subjects: {\r\n        math: 95,\r\n        science: 90\r\n    }\r\n};\r\n\r\nconsole.log(student.subjects.math); // Output: 95",
      "\nObject Methods \n1. Object.assign(): Copies properties from one or more source objects to a target object.",
      "const person1 = { name: \"Alice\" };\r\nconst person2 = { age: 25 };\r\nconst person = Object.assign({}, person1, person2);\r\nconsole.log(person); // Output: { name: \"Alice\", age: 25 }",
      "2. Object.freeze(): Makes an object immutable, preventing modification of its properties.",
      "const person = { name: \"Alice\" };\r\nObject.freeze(person);\r\nperson.name = \"Bob\"; // This will not work\r\nconsole.log(person); // Output: { name: \"Alice\" }",
      "3. Object.seal(): Prevents adding or deleting properties but allows modification of existing properties.",
      "const person = { name: \"Alice\" };\r\nObject.seal(person);\r\nperson.name = \"Bob\"; // Works\r\nperson.age = 25;     // This will not work",
      "4. Object.keys() and Object.values(): Retrieve an array of keys or values from an object.",
      "const person = { name: \"Alice\" };\r\nconsole.log(Object.keys(person)) // Output: [ 'name' ]\r\nconsole.log(Object.values(person)) // Output: [ 'Alice' ]",
      "5. Object.entries(): Retrieves an array of key-value pairs from an object. \n\nMerging and Copying Objects \n1. Using Object.assign():",
      "const person = { name: \"Alice\" };\r\nconst details = { age: 25, city: \"New York\" };\r\nconst merged = Object.assign({}, person, details);\r\nconsole.log(merged); // Output: { name: \"Alice\", age: 25, city: \"New York\" }",
      "2. Using the Spread Operator (...):",
      "const merged = { ...person, ...details };",
      "\nChecking for Properties \n1. in Operator:",
      "console.log(\"name\" in person); // Output: true",
      "2. hasOwnProperty() Method:",
      "console.log(person.hasOwnProperty(\"age\")); // Output: true or false",
      "\nJSON and Objects \nJavaScript objects can be converted to JSON (JavaScript Object Notation), a text format for storing and transferring data. \n\nConvert an Object to JSON:",
      "const jsonString = JSON.stringify(person);\r\nconsole.log(jsonString); // Output: '{\"name\":\"Alice\",\"age\":25}'",
      "Convert JSON to an Object:",
      "const json = '{\"name\":\"Alice\",\"age\":25}';\r\nconst obj = JSON.parse(json);\r\nconsole.log(obj); // Output: { name: \"Alice\", age: 25 }",
      "\nSummary \n• Objects in JavaScript are key-value pairs that can contain any data type, including other objects and functions. \n• Properties can be accessed and modified using dot notation or bracket notation. \n• Methods such as Object.keys(), Object.values(), and Object.entries() allow easy iteration over an object's properties. \n• You can freeze (Object.freeze()) or seal (Object.seal()) objects to limit changes. \n• Objects can be converted to JSON format using JSON.stringify() and parsed back using JSON.parse()."
    ],
    "indices": [
      2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
      40, 42, 44, 46, 48, 50
    ],
    "highlightWords": [
      "•",
      "Creating an Object",
      "Accessing Object Properties",
      "Using Object Literals",
      "this Keyword in Objects",
      "Using the new Object() Constructor:",
      "Using the Object.create() Method:",
      "1. Dot Notation:",
      "2. Bracket Notation",
      "Modifying Object Properties",
      "Add or Update a Property:",
      "Delete a Property:",
      "Methods in Objects",
      "Example:",
      "Looping Through Object Properties",
      "1. for...in Loop:",
      "2. Object.keys():",
      "3. Object.values():",
      "1. Object.assign():",
      "2. Object.freeze():",
      "3. Object.seal():",
      "4. Object.keys()",
      "5. Object.entries():",
      "Object Methods",
      "Nested Objects",
      "Object.values():",
      "4. Object.entries():",
      "Merging and Copying Objects",
      "1. Using Object.assign():",
      "2. Using the Spread Operator (...):",
      "Checking for Properties",
      "1. in Operator:",
      "2. hasOwnProperty() Method:",
      "JSON and Objects",
      "Convert an Object to JSON:",
      "summary"
    ]
  },
  {
    "id": 7,
    "title": "let and const",
    "description": [
      "In JavaScript, both let and const were introduced in ES6 (ECMAScript 2015) to provide better control over variable scoping and behavior compared to the older var keyword. Although they are similar in many ways, there are key differences between let and const that determine when and how to use them.",
      "1. let Keyword: \n• let allows you to declare variables that are block-scoped. This means that they are only accessible within the block { } in which they are defined (e.g., inside a loop, if statement, or function). \n\n• Unlike var, variables declared with let are not hoisted in the same way. They are hoisted, but they are not initialized, and if you try to access them before their declaration, it will throw a ReferenceError due to the temporal dead zone (TDZ). \n\n• Variables declared with let can be updated, but they cannot be redeclared within the same scope. \n\nExample:",
      "let x = 10; \nx = 20; // This is allowed (reassignment) \nconsole.log(x); // Output: 20 \n\nlet x = 30; // SyntaxError: Identifier 'x' has already been declared",
      "\nBlock Scope Example:",
      "let a = 10; \nif (true) { \n let a = 20; // This 'a' is scoped to this block \n console.log(a); // Output: 20 \n} \nconsole.log(a); // Output: 10",
      "\n2. const Keyword: \n• const is used to declare variables that are also block-scoped, but with one important difference: the value of a variable declared with const cannot be reassigned after it is initialized. \n\n• Constant references must be initialized at the time of declaration and cannot be left undefined. Once a value is assigned to a const variable, it cannot be changed. \n\n• Like let, const variables are hoisted but are also subject to the temporal dead zone (TDZ), meaning they are not accessible until they are declared in the code. \n\n• Although a const variable itself cannot be reassigned, if the value is an object or array, the contents of the object or array can still be modified. This is because const only prevents reassigning the variable reference, not the data inside the object or array. \n\nExample:",
      "const y = 10; \ny = 20; // TypeError: Assignment to constant variable",
      "Object with const:",
      "const person = { name: 'Alice' age: 25 }; \nperson.age = 30; // This is allowed (modifying properties of the object) \nconsole.log(person.age); // Output: 30 \n\n// However, you cannot reassign the `person` object itself: \nperson = { name: 'Bob', age: 40 }; // TypeError: Assignment to constant variable",
      "\n3. When to Use let and const: \n• Use const by default for variables that will not change during the program’s execution. This makes your code easier to understand and maintain, as it indicates that the value is constant. \n\n• Use let when you expect the value of the variable to change, such as in loops, conditionals, or during reassignment.",
      "\nSummary: \n• let allows you to declare variables with block scope that can be updated later. \n\n• const allows you to declare block-scoped constants that cannot be reassigned after they are initialized. \n\n• In modern JavaScript development, it is recommended to use const for values that should not change and let when the value will change, avoiding var entirely for better scoping control and predictability."
    ],
    "indices": [2, 4, 6, 8],
    "highlightWords": [
      "•",
      "1. let Keyword:",
      "block-scoped.",
      "ReferenceError",
      "temporal dead zone (TDZ)",
      "Example:",
      "Block Scope Example:",
      "2. const Keyword:",
      "3. When to Use let and const:",
      "Summary:",
      "Object with const:"
    ]
  },
  {
    "id": 8,
    "title": "Functions",
    "description": [
      "In JavaScript, functions are blocks of reusable code designed to perform specific tasks. They can take inputs (called parameters), process the inputs, and return an output (optional). \nFunctions are fundamental building blocks in JavaScript programming, allowing you to write modular, maintainable, and organized code.",
      "1. Function Declaration \nA function declaration defines a named function that can be invoked or called elsewhere in your code. \n\nSyntax:",
      "function functionName(parameters) { \n // Code to be executed \n return value; // (optional) \n}",
      "\nExample:",
      "function greet(name) { \n return 'Hello, ' + name + '!'; \n} \nconsole.log(greet('Alice')); // Output: Hello, Alice!",
      "• The function greet takes one parameter name and returns a greeting message. \n• You can call this function with different arguments to get different outputs.",
      "2. Function Expression \nIn a function expression, the function is assigned to a variable. The function can be anonymous (i.e., it doesn't need a name). \n\nSyntax:",
      "const variableName = function(parameters) { \n // Code to be executed \n};",
      "Example:",
      "const add = function(a, b) { \n return a + b; \n}; \nconsole.log(add(5, 3)); // Output: 8",
      "• The function here is anonymous and assigned to the variable add. \n• You can call add like any other function.",
      "3. Arrow Functions (introduced in ES6) \nArrow functions are a more concise syntax for writing function expressions. They do not have their own this value and are best used for short, simple functions. \n\nSyntax:",
      "const functionName = (parameters) => { \n // Code to be executed \n};",
      "If the function has a single statement, you can omit the braces {} and the return keyword. \n\nExamples: \nBasic Example:",
      "const multiply = (a, b) => a * b; \nconsole.log(multiply(4, 2)); // Output: 8",
      "With multiple lines:",
      "const subtract = (a, b) => { \n const result = a - b; \n return result; \n}; \nconsole.log(subtract(10, 4)); // Output: 6",
      "\n4. Immediately Invoked Function Expression (IIFE) \nAn IIFE is a function that runs as soon as it is defined. It's often used to avoid polluting the global scope and create private scopes. \n\nSyntax:",
      "(function() { \n // Code to be executed \n})();",
      "Example:",
      "(function() { \n let message = 'This is an IIFE!'; \n console.log(message); // Output: This is an IIFE! \n})();",
      "The function is defined and immediately executed, making its variables and logic private.",
      "5. Parameters and Arguments \nParameters: These are variables listed as part of the function definition. \nArguments: These are the actual values passed to the function when it is invoked. \n\nExample:",
      "function add(a, b) { // 'a' and 'b' are parameters \n return a + b; \n} \nconsole.log(add(2, 3)); // 2 and 3 are arguments passed when calling the function  ",
      "\n6. Default Parameters (introduced in ES6) \nYou can assign default values to parameters in case no argument is passed for them during the function call. \n\nExample:",
      "function greet(name = 'Guest') { \n return 'Hello, ' + name + '!'; \n} \nconsole.log(greet()); // Output: Hello, Guest! \nconsole.log(greet('Alice')); // Output: Hello, Alice!  ",
      "If no argument is passed to the greet function, it will use the default value 'Guest'.",
      "7. Rest Parameters (introduced in ES6) \nRest parameters allow you to handle an indefinite number of arguments as an array. They are written as ... followed by the parameter name. \n\nExample:",
      "function sum(...numbers) { \n return numbers.reduce((total, num) => total + num, 0); \n} \nconsole.log(sum(1, 2, 3, 4)); // Output: 10",
      "The sum function can accept any number of arguments, and they are grouped into the numbers array.",
      "8. Return Statement \nThe return statement ends function execution and specifies a value to be returned to the function caller. \n\nExample:",
      "function square(x) { \n return x * x; \n} \nconsole.log(square(5)); // Output: 25",
      "If there is no return statement, the function returns undefined by default.",
      "9. Function Scope \nFunctions in JavaScript have their own scope. Variables declared inside a function are not accessible outside that function. \n\nExample:",
      "function outer() { \n let innerVariable = 'I am inside a function!'; \n console.log(innerVariable); // Accessible inside the function \n} \nouter(); \nconsole.log(innerVariable); // ReferenceError: innerVariable is not defined  ",
      "\n10. Function Hoisting \nFunction declarations are hoisted to the top of their scope, meaning you can call a function before it's defined. \nMore details available in the hoisting topic.",
      "11. Anonymous Functions \nAnonymous functions are functions without a name. They are often used as arguments to other functions. \n\nExample:",
      "setTimeout(function() { \n console.log('This runs after 2 seconds'); \n}, 2000);",
      "\n12. Higher-Order Functions \nA higher-order function is a function that can take another function as an argument or return a function as a result. \n\nExample:",
      "function greet() { \n return function(name) { \n return 'Hello, ' + name; \n }; \n} \nconst greeter = greet(); \nconsole.log(greeter('Alice')); // Output: Hello, Alice  ",
      "\nSummary: \n• Function Declaration: function myFunc() { } \n• Function Expression: const myFunc = function() { } \n• Arrow Function: const myFunc = () => { } \n• Functions can have parameters, return values, and are block-scoped. \n• You can use default parameters, rest parameters, and functions can be higher-order. \n\nFunctions in JavaScript are incredibly versatile, making them powerful tools for creating reusable, modular code."
    ],
    "indices": [2, 4, 7, 9, 12, 14, 16, 18, 20, 23, 25, 28, 31, 34, 37, 39],
    "highlightWords": [
      "1. Function Declaration",
      "Syntax:",
      "Example:",
      "Examples:",
      "Basic Example:",
      "with multiple lines:",
      "2. Function Expression",
      "3. Arrow Functions (introduced in ES6)",
      "4. Immediately Invoked Function Expression (IIFE)",
      "5. Parameters and Arguments",
      "Parameters:",
      "Arguments:",
      "6. Default Parameters (introduced in ES6)",
      "7. Rest Parameters (introduced in ES6)",
      "8. Return Statement",
      "9. Function Scope",
      "10. Function Hoisting",
      "11. Anonymous Functions",
      "12. Higher-Order Functions",
      "Summary:",
      "Function Declaration:",
      "Function Expression:",
      "Arrow Function:"
    ]
  },
  {
    "id": 9,
    "title": "Hoisting",
    "description": [
      "Hoisting in JavaScript is a behavior in which variable and function declarations are moved to the top of their containing scope (either the global scope or function scope) during the compile phase, before the code is executed. This means that you can use variables and functions before they are declared in the code, although how they behave can vary depending on whether they were declared with var, let, const, or as a function.\n\nKey Points About Hoisting: \n\n1. Variable Hoisting with var: \nVariables declared with var are hoisted to the top of their function or global scope. \nHowever, only the declaration is hoisted, not the initialization. So, if you try to use the variable before it is assigned a value, it will be undefined. \n\nExample:",
      "console.log(x); // Output: undefined (because declaration is hoisted) \nvar x = 10; \nconsole.log(x); // Output: 10",
      "Behind the scenes, this code is interpreted as:",
      "var x; // Declaration is hoisted \nconsole.log(x); // undefined, as x is declared but not yet initialized \nx = 10; // Initialization happens later \nconsole.log(x); // 10",
      "\n2. Variable Hoisting with let and const: \nVariables declared with let and const are also hoisted, but they are not initialized during hoisting. This leads to a temporal dead zone (TDZ), meaning you cannot use the variable until the actual line of code where it's defined is executed. \nAccessing the variable before it is initialized will result in a ReferenceError. \n\nExample with let:",
      "console.log(y); // ReferenceError: Cannot access 'y' before initialization \nlet y = 20;",
      "\nExample with const:",
      "console.log(z); // ReferenceError: Cannot access 'z' before initialization \nconst z = 30;",
      "\n3. Function Hoisting: \nFunction declarations are fully hoisted. This means both the declaration and the function body are hoisted to the top of the scope, so you can call the function before its declaration in the code. \n\nExample:",
      "greet(); // Output: Hello! \n\nfunction greet() { \n console.log('Hello!'); \n}",
      "Function expressions, whether declared with var, let, or const, are not hoisted in the same way. If a function is assigned to a variable, only the variable is hoisted (as with var), but the function itself is not initialized until the assignment line is reached. \n\nExample with function expression:",
      "console.log(sayHello); // Output: undefined \nvar sayHello = function() { \n console.log('Hello!'); \n}; \nsayHello(); // Output: Hello!",
      "If you try to use a function expression before the variable assignment, it will throw a TypeError if it's declared with let or const",
      "Summary: \n• Variables declared with var are hoisted to the top, but their values are initialized as undefined until the assignment occurs. \n\n• Variables declared with let and const are hoisted but cannot be accessed before their declaration due to the temporal dead zone. \n\n• Function declarations are fully hoisted, so they can be called before their definition. \n\n• Function expressions (even if declared with var, let, or const) are not fully hoisted and behave like variable hoisting.\n\nHoisting Example:",
      "function testHoisting() { \n console.log(a); // undefined (because of var hoisting) \n console.log(b); // ReferenceError (because let is hoisted but in TDZ) \n console.log(c); // ReferenceError (because const is hoisted but in TDZ) \n\n var a = 1; \n let b = 2; \n const c = 3; \n\n console.log(a); // 1 \n console.log(b); // 2 \n console.log(c); // 3 \n} \ntestHoisting();"
    ],
    "indices": [1, 3, 5, 7, 9, 11, 14],
    "highlightWords": [
      "•",
      "Key Points About Hoisting:",
      "1. Variable Hoisting with var:",
      "Example:",
      "2. Variable Hoisting with let and const:",
      "temporal dead zone (TDZ)",
      "Example with let:",
      "Example with const:",
      "3. Function Hoisting:",
      "Summary:",
      "Hoisting Example:",
      "Example with function expression:",
      "Example with let:",
      "Example with const:"
    ]
  },
  {
    "id": 10,
    "title": "Closure",
    "description": [
      "In JavaScript, a closure is a function that has access to its own scope, the scope of the outer function, and the global scope, even after the outer function has finished executing.",
      "Closures allow inner functions to access variables and parameters of outer functions, even after the outer function has returned.",
      "Key Concepts of Closures: \n\nFunction within a Function: A closure involves a function defined inside another function (the outer function). \n\nScope Chain: The inner function has access to variables from: \n• Its own local scope. \n• The outer function's scope. \n• The global scope. \n\nPersistence of Scope: Even when the outer function finishes execution, the inner function retains access to the variables in the outer function’s scope. \n\nExample of a Closure:",
      "function outerFunction(outerVariable) { \n return function innerFunction(innerVariable) { \n  console.log('Outer Variable: ' + outerVariable); \n  console.log('Inner Variable: ' + innerVariable); \n }; \n} \nconst newFunction = outerFunction('outside'); \nnewFunction('inside'); \n// Output: \n// Outer Variable: outside \n// Inner Variable: inside",
      "Explanation: \n• outerFunction takes one argument outerVariable and returns the innerFunction. \n• innerFunction can access both innerVariable (its own variable) and outerVariable (from the outer scope). \n• Even after outerFunction has finished execution, newFunction retains access to the outerVariable from outerFunction's scope.",
      "How Closures Work: \nWhen the outerFunction is called, it returns the innerFunction. The returned function retains a reference to the variables declared in outerFunction, creating a closure. This means even after outerFunction finishes executing, the inner function still 'remembers' the variables from the outer scope.",
      "Practical Use Cases of Closures: \n1. Data Privacy (Encapsulation): \nClosures can be used to create private variables and functions that are not accessible from outside the function. This is a common technique in JavaScript to simulate private members in classes. \n\nExample:",
      "function counter() { \n let count = 0; \n return function() { \n count++; \n return count; \n }; \n} \nconst increment = counter(); \nconsole.log(increment()); // Output: 1 \nconsole.log(increment()); // Output: 2 \nconsole.log(increment()); // Output: 3",
      "Explanation: \nThe variable count is private to the counter function and cannot be accessed directly from outside. \n• The inner function returned from counter forms a closure, allowing access to the count variable, which is preserved between function calls. \n\n2. Function Factories: \n• Closures allow you to create 'function factories' – functions that return other functions configured with specific data. \n\nExample:",
      "function createMultiplier(multiplier) { \n return function(value) { \n return value * multiplier; \n }; \n} \nconst double = createMultiplier(2); \nconst triple = createMultiplier(3); \nconsole.log(double(5)); // Output: 10 \nconsole.log(triple(5)); // Output: 15",
      "Explanation: \n• The createMultiplier function returns a new function that multiplies a given number by the multiplier passed to createMultiplier. \n• Each returned function remembers its own multiplier value thanks to closures. \n\n3. Event Handlers in Web Development: \nClosures are often used in JavaScript event handling to maintain access to the variables from an outer function, even after an event occurs. \n\nExample:",
      "function setupClickHandler(message) { \n document.getElementById('myButton').addEventListener('click', function() { \n alert(message); \n }); \n} \nsetupClickHandler('Button clicked!');",
      "Explanation: \n• The inner function (the event handler) can access the message variable from the outer setupClickHandler function even after setupClickHandler has executed. \n\n4. Callback Functions: \nClosures are frequently used in asynchronous programming, where a function (callback) is executed after some event, like a timeout or a data fetch. \n\nExample:",
      "function delayedGreeting(name) { \n setTimeout(function() { \n console.log('Hello, ' + name); \n }, 2000); \n} \ndelayedGreeting('Alice'); // Output after 2 seconds: Hello, Alice",
      "Explanation: \n• The anonymous function inside setTimeout forms a closure and retains access to the name parameter even after delayedGreeting has finished executing. \n\nCommon Pitfalls with Closures: \n1. Accidental Capture of Loop Variables: When closures are used inside loops, all closures might capture the same variable, leading to unexpected results. \n\nExample (Problem):",
      "for (var i = 1; i <= 3; i++) { \n setTimeout(function() { \n console.log(i); \n }, 1000); \n} \n// Output: 1, 2, 3 (after 1 second)",
      "Explanation: \n• The closure created by the anonymous function inside setTimeout captures the same i variable. By the time the setTimeout callback is executed, the loop has completed, and i is 4. \n\nSolution: Use let instead of var in the loop, since let has block scope.",
      "for (let i = 1; i <= 3; i++) { \n setTimeout(function() { \n console.log(i); \n }, 1000); \n} \n// Output: 1, 2, 3 (after 1 second)",
      "\nAdvantages of Closures: \n\nData Encapsulation: Closures allow you to hide implementation details and create private variables. \n\nState Persistence: Functions can remember and access variables from their containing scope, making closures perfect for stateful programming. \n\nFunctional Programming: Closures are a core concept in functional programming, enabling higher-order functions and function composition.",
      "Summary: \nA closure is a powerful feature in JavaScript that allows a function to retain access to the variables of its outer scope, even after that outer function has finished executing. \nClosures enable data privacy, function factories, event handlers, and more, making them an essential tool in JavaScript programming."
    ],
    "highlightWords": [
      "•",
      "Key Concepts of Closures:",
      "Function within a Function:",
      "Scope Chain: ",
      "Persistence of Scope:",
      "Example of a Closure:",
      "Explanation:",
      "How Closures Work:",
      "Practical Use Cases of Closures:",
      "Data Privacy (Encapsulation):",
      "Example:",
      "Function Factories:",
      "Event Handlers in Web Development:",
      "Callback Functions:",
      "Common Pitfalls with Closures:",
      "Accidental Capture of Loop Variables:",
      "Example (Problem):",
      "Solution:",
      "Advantages of Closures:",
      "Data Encapsulation:",
      "State Persistence:",
      "Functional Programming:",
      "Summary:"
    ],
    "indices": [3, 7, 9, 11, 13, 15, 17]
  },
  {
    "id": 11,
    "title": "Promises",
    "description": [
      "In JavaScript, a Promise is an object representing the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises provide a more elegant way to handle asynchronous code compared to traditional callback functions, making the code easier to read, chain, and manage error handling. \n\nKey Concepts of Promises:",
      "1. States of a Promise: \nPending: The initial state. The promise has not yet been fulfilled or rejected. \nFulfilled: The operation completed successfully, and the promise has a value (resolved). \nRejected: The operation failed, and the promise has a reason (error).",
      "2. Methods to Handle Promises: \n.then(): Used to handle the fulfillment of a promise and access the result (value). \n.catch(): Used to handle errors or rejections of a promise. \n.finally(): Optional; used to execute code once a promise is settled (either fulfilled or rejected). \n\nBasic Example of a Promise:",
      "const promise = new Promise((resolve, reject) => { \n const success = true; \n if (success) { \n  resolve('Operation was successful'); \n } else { \n  reject('Operation failed'); \n } \n}); \n\n// Handling the Promise result \npromise \n .then(result => console.log(result)) // Output: Operation was successful \n .catch(error => console.log(error)); // In case of failure (if success is false)",
      "• The Promise constructor takes a function (executor function) with two arguments: resolve and reject. You call resolve() when the operation is successful, and reject() when the operation fails. \n• The .then() method is used to handle the result if the promise is fulfilled, while .catch() is used to handle the error if it is rejected.",
      "Chaining Promises: \nPromises can be chained to perform a series of asynchronous operations in sequence, with each subsequent .then() receiving the result of the previous promise. \n\nExample:",
      "const fetchData = new Promise((resolve, reject) => { \n setTimeout(() => resolve('Data fetched'), 1000); \n}); \nfetchData \n .then(result => { \n  console.log(result); // Output: Data fetched \n  return 'Processed Data'; \n }) \n .then(result => { \n  console.log(result); // Output: Processed Data \n  return 'More Processing'; \n }) \n .then(result => { \n  console.log(result); // Output: More Processing \n }) \n .catch(error => console.log(error));",
      "The result of each .then() is passed to the next one, creating a chain of asynchronous operations.",
      "Error Handling in Promises: \nWhen a promise is rejected, or an error occurs, you can handle it using .catch(). Errors are also propagated down the promise chain, so a single .catch() can handle multiple errors in a chain. \n\nExample:",
      "const fetchData = new Promise((resolve, reject) => { \n setTimeout(() => reject('Failed to fetch data'), 1000); \n}); \nfetchData \n .then(result => console.log(result)) \n .catch(error => console.log('Error: ' + error)); // Output: Error: Failed to fetch data",
      "If any part of the chain throws an error or is rejected, the .catch() block will handle it.",
      "Promise.all(), Promise.race(), Promise.allSettled(), and Promise.any(): \n\n1. Promise.all(): \n• Waits for all promises in an array to be fulfilled. \n• If one promise is rejected, the entire Promise.all() call is rejected. \n\nExample:",
      "const p1 = Promise.resolve('Promise 1'); \nconst p2 = Promise.resolve('Promise 2'); \nconst p3 = Promise.resolve('Promise 3'); \nPromise.all([p1, p2, p3]) \n .then(results => console.log(results)) // Output: [ 'Promise 1', 'Promise 2', 'Promise 3' ] \n .catch(error => console.log(error));",
      "\n2. Promise.race(): \nReturns a promise that resolves or rejects as soon as one of the promises resolves or rejects. \n\nExample:",
      "const p1 = new Promise(resolve => setTimeout(resolve, 100, 'First')); \nconst p2 = new Promise(resolve => setTimeout(resolve, 200, 'Second')); \nPromise.race([p1, p2]) \n .then(result => console.log(result)); // Output: First",
      "\n3. Promise.allSettled(): \nWaits for all promises to settle (either fulfilled or rejected) and returns an array of objects representing the results. \n\nExample:",
      "const p1 = Promise.resolve('Resolved'); const p2 = Promise.reject('Rejected'); Promise.allSettled([p1, p2]) \n .then(results => console.log(results)); \n// Output: \n// [ \n// { status: 'fulfilled', value: 'Resolved' }, \n// { status: 'rejected', reason: 'Rejected' } \n// ]",
      "\n4. Promise.any(): \nResolves as soon as any of the promises in the array resolves. If all promises are rejected, it throws an aggregate error. \n\nExample:",
      "const p1 = Promise.reject('Error 1'); \nconst p2 = Promise.reject('Error 2'); \nconst p3 = Promise.resolve('First success'); \nPromise.any([p1, p2, p3]) \n .then(result => console.log(result)) // Output: First success \n .catch(error => console.log(error));",
      "\nAsync/Await (Built on Promises): \nasync and await provide a way to write asynchronous code that looks and behaves more like synchronous code, making it easier to understand. Behind the scenes, they work with Promises. \n\nExample with Async/Await:",
      "function fetchData() { \n return new Promise((resolve, reject) => { \n  setTimeout(() => { \n   resolve('Data fetched'); \n  }, 2000); \n }); \n} \n\nasync function getData() { \n try { \n  const data = await fetchData(); \n  console.log(data); // Output: Data fetched \n } catch (error) { \n  console.log(error); \n } \n} \n\ngetData();",
      "• async functions always return a promise. \n• await pauses the execution of the async function until the promise is resolved or rejected.",
      "Summary: \n• A Promise represents the eventual result of an asynchronous operation. \n• Promises have three states: pending, fulfilled, or rejected. \n• You handle a promise using .then() for success, .catch() for errors, and .finally() for code that should run regardless of the result. \n• Chaining allows multiple asynchronous operations to be performed in sequence. \n• Promise.all(), Promise.race(), Promise.allSettled(), and Promise.any() offer advanced ways of handling multiple promises at once. \n• Async/await is a modern syntax that makes working with Promises cleaner and more readable."
    ],
    "highlightWords": [
      "•",
      "Key Concepts of Promises:",
      "1. States of a Promise:",
      "Pending:",
      "Fulfilled:",
      "Rejected:",
      "2. Methods to Handle Promises:",
      ".then():",
      ".catch():",
      ".finally():",
      "Basic Example of a Promise:",
      "Chaining Promises:",
      "Example:",
      "Error Handling in Promises:",
      "1. Promise.all():",
      "2. Promise.race():",
      "3. Promise.allSettled():",
      "4. Promise.any():",
      "Async/Await (Built on Promises):",
      "Example with Async/Await:",
      "Summary:"
    ],
    "indices": [3, 6, 9, 12, 14, 16, 18, 20]
  }
]
