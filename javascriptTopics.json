[
  {
    "id": 1,
    "title": "What is Javacript",
    "description": "JavaScript is a high-level, dynamic programming language primarily used for web development. \nIt allows developers to create interactive and dynamic content on websites, such as animations, form validations, games, and real-time updates. \nIt works alongside HTML (which structures a webpage) and CSS (which styles a webpage) to enhance user experiences. \n\nHere are some key features of JavaScript: \n\nClient-Side Scripting: \nJavaScript is mainly executed in the browser (client-side), allowing web pages to respond to user interactions without needing to reload the page. \n\nInteractivity: \nJavaScript can manipulate the HTML and CSS of a webpage, making it possible to update content, animate elements, handle user input, and create interactive features. \n\nEvent-Driven: \nJavaScript is designed to react to user actions (events) like clicks, form submissions, and keystrokes. \n\nVersatile: \nWhile traditionally used for web development, JavaScript can also be used on servers (with Node.js), in mobile applications, game development, and more. \n\nRich Ecosystem: \nIt has a large community, numerous libraries (e.g., React, Angular, Vue.js), and frameworks that extend its functionality, making it one of the most popular programming languages today.",
    "highlightWords": [
      "client-side scripting:",
      "interactivity:",
      "event-driven:",
      "versatile:",
      "rich ecosystem:",
      "here are some key features of javascript:"
    ]
  },
  {
    "id": 2,
    "title": "Variables",
    "description": "In JavaScript, variables are used to store data values that can be referenced and manipulated throughout a program. You can think of a variable as a container for storing information. \n\nWays to Declare Variables: \nvar: \nThe original way to declare variables in JavaScript. \nHas function scope, meaning it is accessible throughout the entire function in which it's declared. \nIf declared outside a function, it's globally scoped. \nCan be redeclared within the same scope. \n\nlet: \nIntroduced in ES6 (ECMAScript 2015). \nHas block scope, meaning it is only accessible within the block (enclosed in {}) where it's declared. \nCannot be redeclared in the same scope. \n\nconst: \nAlso introduced in ES6. \nLike let, it has block scope. \nHowever, variables declared with const cannot be reassigned after their initial value is set. \nUseful for variables that should remain constant. \n\nVariable Naming Rules: \nVariable names can include letters, numbers, underscores, and dollar signs. \nThey must begin with a letter, underscore (_), or dollar sign ($). \nJavaScript is case-sensitive, so myVariable and MyVariable are different variables.",
    "highlightWords": [
      "ways to declare variables:",
      "let:",
      "const:",
      "var:",
      "variable naming rules:"
    ]
  },
  {
    "id": 3,
    "title": "Data Types",
    "description": "JavaScript has several data types that represent the different kinds of values that can be stored and manipulated in a program. \nThese are broadly classified into primitive types and non-primitive (reference) types. \n\n1.Primitive Data Types: \nThese are the basic data types in JavaScript and represent single values. They are immutable, meaning their values cannot be altered once assigned. \n\nNumber: \nRepresents both integer and floating-point numbers. \n\nString: \nUsed to represent textual data. Strings are enclosed in single double quotes. \n\nBoolean: \nRepresents one of two values: true or false. Often used in conditional testing. \n\nUndefined: \nA variable that has been declared but not assigned a value is of type undefined. \n\nNull: \nRepresents the intentional absence of any object value. It is used to indicate 'no value.' \n\nSymbol (Introduced in ES6): \nA unique and immutable value, often used to create unique object property keys. \nBigInt (Introduced in ES2020): \nUsed to represent integers larger than the Number type can handle. \n\n2.Non-Primitive (Reference) Data Types: \nThese are data types that are more complex, and they refer to objects that may have properties and methods. \n\nObject: \nA collection of key-value pairs. An object can contain multiple properties and functions (methods). \n\nArray: \nA special type of object used to store ordered lists of values. \n\nFunctions: \nFunctions are also treated as objects in JavaScript, allowing them to be assigned to variables, passed as arguments, or returned from other functions. \n\nType Checking: \nTo check the type of a variable, you can use the typeof operator",
    "highlightWords": [
      "1.primitive data types:",
      "number:",
      "string:",
      "boolean:",
      "undefined:",
      "null:",
      "symbol (introduced in es6):",
      "2.non-primitive (reference) data types:",
      "object:",
      "array:",
      "functions:",
      "type checking:"
    ]
  },
  {
    "id": 4,
    "title": "let and const",
    "description": [
      "In JavaScript, both let and const were introduced in ES6 (ECMAScript 2015) to provide better control over variable scoping and behavior compared to the older var keyword. Although they are similar in many ways, there are key differences between let and const that determine when and how to use them.",
      "1. let Keyword: \n• let allows you to declare variables that are block-scoped. This means that they are only accessible within the block { } in which they are defined (e.g., inside a loop, if statement, or function). \n\n• Unlike var, variables declared with let are not hoisted in the same way. They are hoisted, but they are not initialized, and if you try to access them before their declaration, it will throw a ReferenceError due to the temporal dead zone (TDZ). \n\n• Variables declared with let can be updated, but they cannot be redeclared within the same scope. \n\nExample:",
      "let x = 10; \nx = 20; // This is allowed (reassignment) \nconsole.log(x); // Output: 20 \n\nlet x = 30; // SyntaxError: Identifier 'x' has already been declared",
      "\nBlock Scope Example:",
      "let a = 10; \nif (true) { \n let a = 20; // This 'a' is scoped to this block \n console.log(a); // Output: 20 \n} \nconsole.log(a); // Output: 10",
      "\n2. const Keyword: \n• const is used to declare variables that are also block-scoped, but with one important difference: the value of a variable declared with const cannot be reassigned after it is initialized. \n\n• Constant references must be initialized at the time of declaration and cannot be left undefined. Once a value is assigned to a const variable, it cannot be changed. \n\n• Like let, const variables are hoisted but are also subject to the temporal dead zone (TDZ), meaning they are not accessible until they are declared in the code. \n\n• Although a const variable itself cannot be reassigned, if the value is an object or array, the contents of the object or array can still be modified. This is because const only prevents reassigning the variable reference, not the data inside the object or array. \n\nExample:",
      "const y = 10; \ny = 20; // TypeError: Assignment to constant variable",
      "Object with const:",
      "const person = { name: 'Alice' age: 25 }; \nperson.age = 30; // This is allowed (modifying properties of the object) \nconsole.log(person.age); // Output: 30 \n\n// However, you cannot reassign the `person` object itself: \nperson = { name: 'Bob', age: 40 }; // TypeError: Assignment to constant variable",
      "\n3. When to Use let and const: \n• Use const by default for variables that will not change during the program’s execution. This makes your code easier to understand and maintain, as it indicates that the value is constant. \n\n• Use let when you expect the value of the variable to change, such as in loops, conditionals, or during reassignment.",
      "\nSummary: \n• let allows you to declare variables with block scope that can be updated later. \n\n• const allows you to declare block-scoped constants that cannot be reassigned after they are initialized. \n\n• In modern JavaScript development, it is recommended to use const for values that should not change and let when the value will change, avoiding var entirely for better scoping control and predictability."
    ],
    "indices": [2, 4, 6, 8],
    "highlightWords": [
      "•",
      "1. let Keyword:",
      "block-scoped.",
      "ReferenceError",
      "temporal dead zone (TDZ)",
      "Example:",
      "Block Scope Example:",
      "2. const Keyword:",
      "3. When to Use let and const:",
      "Summary:",
      "Object with const:"
    ]
  },
  {
    "id": 5,
    "title": "Hoisting",
    "description": [
      "Hoisting in JavaScript is a behavior in which variable and function declarations are moved to the top of their containing scope (either the global scope or function scope) during the compile phase, before the code is executed. This means that you can use variables and functions before they are declared in the code, although how they behave can vary depending on whether they were declared with var, let, const, or as a function.\n\nKey Points About Hoisting: \n\n1. Variable Hoisting with var: \nVariables declared with var are hoisted to the top of their function or global scope. \nHowever, only the declaration is hoisted, not the initialization. So, if you try to use the variable before it is assigned a value, it will be undefined. \n\nExample:",
      "console.log(x); // Output: undefined (because declaration is hoisted) \nvar x = 10; \nconsole.log(x); // Output: 10",
      "Behind the scenes, this code is interpreted as:",
      "var x; // Declaration is hoisted \nconsole.log(x); // undefined, as x is declared but not yet initialized \nx = 10; // Initialization happens later \nconsole.log(x); // 10",
      "\n2. Variable Hoisting with let and const: \nVariables declared with let and const are also hoisted, but they are not initialized during hoisting. This leads to a temporal dead zone (TDZ), meaning you cannot use the variable until the actual line of code where it's defined is executed. \nAccessing the variable before it is initialized will result in a ReferenceError. \n\nExample with let:",
      "console.log(y); // ReferenceError: Cannot access 'y' before initialization \nlet y = 20;",
      "\nExample with const:",
      "console.log(z); // ReferenceError: Cannot access 'z' before initialization \nconst z = 30;",
      "\n3. Function Hoisting: \nFunction declarations are fully hoisted. This means both the declaration and the function body are hoisted to the top of the scope, so you can call the function before its declaration in the code. \n\nExample:",
      "greet(); // Output: Hello! \n\nfunction greet() { \n console.log('Hello!'); \n}",
      "Function expressions, whether declared with var, let, or const, are not hoisted in the same way. If a function is assigned to a variable, only the variable is hoisted (as with var), but the function itself is not initialized until the assignment line is reached. \n\nExample with function expression:",
      "console.log(sayHello); // Output: undefined \nvar sayHello = function() { \n console.log('Hello!'); \n}; \nsayHello(); // Output: Hello!",
      "If you try to use a function expression before the variable assignment, it will throw a TypeError if it's declared with let or const",
      "Summary: \n• Variables declared with var are hoisted to the top, but their values are initialized as undefined until the assignment occurs. \n\n• Variables declared with let and const are hoisted but cannot be accessed before their declaration due to the temporal dead zone. \n\n• Function declarations are fully hoisted, so they can be called before their definition. \n\n• Function expressions (even if declared with var, let, or const) are not fully hoisted and behave like variable hoisting.\n\nHoisting Example:",
      "function testHoisting() { \n console.log(a); // undefined (because of var hoisting) \n console.log(b); // ReferenceError (because let is hoisted but in TDZ) \n console.log(c); // ReferenceError (because const is hoisted but in TDZ) \n\n var a = 1; \n let b = 2; \n const c = 3; \n\n console.log(a); // 1 \n console.log(b); // 2 \n console.log(c); // 3 \n} \ntestHoisting();"
    ],
    "indices": [1, 3, 5, 7, 9, 11, 14],
    "highlightWords": [
      "•",
      "Key Points About Hoisting:",
      "1. Variable Hoisting with var:",
      "Example:",
      "2. Variable Hoisting with let and const:",
      "temporal dead zone (TDZ)",
      "Example with let:",
      "Example with const:",
      "3. Function Hoisting:",
      "Summary:",
      "Hoisting Example:",
      "Example with function expression:",
      "Example with let:",
      "Example with const:"
    ]
  }
]
